<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xyfu.me').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="二叉树的DFS：⭕️LC144 Binary Tree Preorder Traversal⭕️LC94 Binary Tree Inorder Traversal⭕️LC145 Binary Tree Postorder Traversal 二叉树的BFS:⭕️LC102 Binary Tree Level Order Traversal⭕️LC107 Binary Tree Level Ord">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://xyfu.me/posts/e85d694a/index.html">
<meta property="og:site_name" content="Xuanyi Fu Blog">
<meta property="og:description" content="二叉树的DFS：⭕️LC144 Binary Tree Preorder Traversal⭕️LC94 Binary Tree Inorder Traversal⭕️LC145 Binary Tree Postorder Traversal 二叉树的BFS:⭕️LC102 Binary Tree Level Order Traversal⭕️LC107 Binary Tree Level Ord">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-08-23T10:25:41.000Z">
<meta property="article:modified_time" content="2020-06-20T06:08:57.458Z">
<meta property="article:author" content="Xuanyi Fu">
<meta property="article:tag" content="二叉树">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xyfu.me/posts/e85d694a/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>二叉树 | Xuanyi Fu Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xuanyi Fu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://xyfu.me/posts/e85d694a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xuanyi Fu">
      <meta itemprop="description" content="Xuanyi Fu的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xuanyi Fu Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二叉树
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-23 18:25:41" itemprop="dateCreated datePublished" datetime="2019-08-23T18:25:41+08:00">2019-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-20 14:08:57" itemprop="dateModified" datetime="2020-06-20T14:08:57+08:00">2020-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>二叉树的DFS：<br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84DFS">LC144 Binary Tree Preorder Traversal</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84DFS">LC94 Binary Tree Inorder Traversal</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84DFS">LC145 Binary Tree Postorder Traversal</a></p>
<p>二叉树的BFS:<br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84BFS">LC102 Binary Tree Level Order Traversal</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84BFS">LC107 Binary Tree Level Order Traversal II</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#Zigzag%E9%81%8D%E5%8E%86">103. Binary Tree Zigzag Level Order Traversal</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6">LC662 二叉树的最大宽度</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE">LC199 二叉树的右视图</a><br><a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC">LC513 找树左下角的值</a><br><a href="https://xyfu.me/posts/e85d694a/#%E5%B1%82%E5%BA%8F%E4%B8%8B%E4%B8%80%E8%8A%82%E7%82%B9">LC116 填充每个节点的下一个右侧节点指针</a><br><a href="https://xyfu.me/posts/e85d694a/#%E5%B1%82%E5%BA%8F%E4%B8%8B%E4%B8%80%E8%8A%82%E7%82%B9">LC117 填充每个节点的下一个右侧节点指针II</a><br><a href="https://xyfu.me/posts/e85d694a/#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8">LC919 完全二叉树插入器</a><br><a href="https://xyfu.me/posts/e85d694a/#%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C">LC1302 层数最深叶子节点的和</a></p>
<p>序列化与反序列化二叉树：<br>⚠️<a href="https://xyfu.me/posts/e85d694a/#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91">LC655 输出二叉树</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">LC297 Serialize and Deserialize Binary Tree</a>[前序遍历，nullptr要有占位符]</p>
<p>二叉树的坐标化：<br><a href="https://xyfu.me/posts/e85d694a/#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91">LC665 输出二叉树</a><br><a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86">LC987 二叉树的垂序遍历</a></p>
<p>根据遍历序列重建二叉树：<br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">LC106 Construct Binary Tree from Inorder and Postorder Traversal</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">LC105 Construct Binary Tree from Preorder and Inorder Traversal</a></p>
<p>向下路径与叶子路径：<br><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">LC129 Sum Root to Leaf Numbers</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%EF%BC%88%E6%9C%80%E5%A4%A7%E5%8F%B6%E5%AD%90%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%EF%BC%89">LC104 Maximum Depth of Binary Tree</a><br>⚠️<a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%EF%BC%88%E6%9C%80%E5%B0%8F%E5%8F%B6%E5%AD%90%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%EF%BC%89">LC111 Minimum Depth of Binary Tree</a><br><a href="https://xyfu.me/posts/e85d694a/#%E5%90%91%E4%B8%8B%E8%B7%AF%E5%BE%84%E5%92%8C">LC257 二叉树的所有路径</a><br><a href="https://xyfu.me/posts/f92eff5d/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84">LC112 Path Sum</a><br><a href="https://xyfu.me/posts/f92eff5d/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84">LC113 Path Sum II</a><br><a href="https://xyfu.me/posts/f92eff5d/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84">LC437 Path Sum III</a></p>
<p>折返路径：<br><a href="https://xyfu.me/posts/e85d694a/#%E6%8A%98%E8%BF%94%E8%B7%AF%E5%BE%84">LC543 二叉树的直径</a><br><a href="https://xyfu.me/posts/e85d694a/#%E6%8A%98%E8%BF%94%E8%B7%AF%E5%BE%84">LC687 最长同值路径</a><br><a href="https://xyfu.me/posts/e85d694a/#%E6%8A%98%E8%BF%94%E8%B7%AF%E5%BE%84">LC124 折返路径和</a><br><a href="https://xyfu.me/posts/e85d694a/#%E6%8A%98%E8%BF%94%E8%B7%AF%E5%BE%84">LC110 平衡二叉树</a></p>
<p>两个二叉树的关系：<br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91">LC100 相同的树</a><br>⭕️<a href="https://xyfu.me/posts/e85d694a/#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">LC面试题26. 树的子结构</a><br><a href="https://xyfu.me/posts/e85d694a/#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">LC572 Subtree of Another Tree</a><br><a href="https://xyfu.me/posts/e85d694a/#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">LC面试题04.10 检查子树</a><br><a href="https://xyfu.me/posts/e85d694a/#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91">LC617 合并二叉树</a></p>
<p>对称的二叉树：<br>❌<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">LC226 求二叉树的镜像</a><br>❌<a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">LC101 Symmertic Tree</a> </p>
<p>最低公共祖先：<br><a href="https://xyfu.me/posts/e85d694a/#%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">LC235 Lowest Common Ancestor of a Binary Search Tree</a><br><a href="https://xyfu.me/posts/e85d694a/#%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">LC236 Lowest Common Ancestor of a Binary Tree</a><br><a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%8F%B6%E8%8A%82%E7%82%B9">LC742 二叉树最近的叶节点</a></p>
<p>其他：<br>⚠️<a href="https://xyfu.me/posts/e8eb0481/#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">LC222 完全二叉树的节点个数</a><br><a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BE%B9%E7%95%8C">LC545 二叉树的边界</a></p>
<p>子树类问题：<br><a href="https://leetcode-cn.com/problems/count-univalue-subtrees/" target="_blank" rel="noopener">LC250 统计同值子树</a><br><a href="https://leetcode-cn.com/problems/maximum-average-subtree/submissions/" target="_blank" rel="noopener">LC1120 子树的最大平均值</a></p>
<a id="more"></a>
<h1 id="二叉树的DFS"><a href="#二叉树的DFS" class="headerlink" title="二叉树的DFS"></a>二叉树的DFS</h1><p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">LC144 Binary Tree Preorder Traversal</a><br><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">LC94 Binary Tree Inorder Traversal</a><br><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">LC145 Binary Tree Postorder Traversal</a></p>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>略。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的最大长度是此二叉树的深度。对于比较平衡的二叉树来说，用栈来模拟递归是很实用的方法。但当二叉树平衡性很差，甚至退化成链表的时候，就要考虑不使用栈的Morris遍历了。</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul>
<li>access</li>
<li>preorderTraversal(root-&gt;left)</li>
<li>preorderTraversal(root-&gt;right)</li>
</ul>
<p>思考使用递归实现前序遍历的时候，函数调用栈的样子。前序遍历的过程中遇到节点就会访问，并且一路向左。因此函数调用栈里保存的信息应该是每一处的右节点。我们每次一直向左走到头的时候，就要去访问其父亲节点的右节点了。思路：</p>
<pre><code>- 遇到节点就访问，并将右节点压入栈中，之后向左走，直到走到头。
- 如果走到头就从栈里取出一个节点，重复上面一步。
- 如果栈空了，那么遍历结束了。
</code></pre><p>可能的优化：</p>
<pre><code>- 将右节点压入栈前，检查右节点是否为空。感觉没有必要。因为增加了一个流程控制语句。不如让`while`循环直接判断。
- 将栈是否为空的判断语句放在外层`while`循环处。并将第一个节点推入栈中。就像调用递归的preorderTraversal一样，需要先把root传入。
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        前序遍历
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> rt = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(rt)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(rt-&gt;val);</span><br><span class="line">                <span class="built_in">stack</span>.push_back(rt-&gt;right);</span><br><span class="line">                rt = rt-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li>preorderTraversal(root-&gt;left)</li>
<li>access</li>
<li>preorderTraversal(root-&gt;right)</li>
</ul>
<p>中序遍历时，遇到节点不会直接访问，而是先深入到左侧节点。直到左侧节点为空，才会访问该节点。之后访问父节点，最后是右子树。因此函数调用栈里保存应该是父节点的信息。</p>
<pre><code>- 每次遇到节点直接压入栈中即可。
- 不断向左移动，直到该节点为空（注意此时这个空节点的父亲节点已经被压入栈中）。这和递归调用的函数调用栈是一致的，我们会持续调用`preorderTraversal(root-&gt;left)`，直到`root-&gt;left == nullptr`时，这个函数会直接返回。返回后就马上开始访问，然后再用右子树重复之前的过程。
- 如果栈空了，遍历结束。
- 如果栈非空，从栈中取出一个节点，访问，移动到他的右节点，重复上述过程。
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        中序遍历
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>&#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// move to its left subtree and push its parent node into stack</span></span><br><span class="line">                <span class="built_in">stack</span>.push_back(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if the stack is empty, traversal ends</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// get a node from the stack and visit.</span></span><br><span class="line">            root = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            <span class="comment">// move to its right subtree, do this again</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><p>如果一个节点是右孩子，或没有兄弟节点的左孩子，访问该节点后会立刻访问该节点的父节点。直接中栈来实现后续遍历非常麻烦。我们可以采用一些小手段。仔细观察后续遍历的序列，可以发现其遍历序列的<strong>逆序</strong>非常类似一个<strong>先右子树，后左子树</strong>的的前序遍历。因此我们可以用栈来实现一个先右后左的前序遍历，然后将结果逆序即可。采用两个栈来实现是没有必要的，reverse算法要比从栈里逆序效率要高。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        先左后右的前序遍历
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// visit the node</span></span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                <span class="comment">// push its LEFT subtree into the stack</span></span><br><span class="line">                <span class="built_in">stack</span>.push_back(root-&gt;left);</span><br><span class="line">                <span class="comment">// move to its RIGHT subtree</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// reverse the result</span></span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h2><p>Morris遍历是一个不断地给节点找后继节点的过程。</p>
<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>空间复杂度为$O(1)$的遍历方法。代价是在遍历过程中会修改树，因此<strong>不能中途退出</strong>，否则树的结构会被破坏。</p>
<p>前序遍历回顾：</p>
<ul>
<li><strong>访问当前节点</strong></li>
<li>尝试进入当前节点左子树<ul>
<li>如果当前节点存在左子树，进入其左子树，回到开头</li>
<li>如果当前节点不存在左子树，尝试进入其右子树<ul>
<li>如果当前节点存在右子树，进入其右子树，回到开头。</li>
<li>如果当前节点不存在右子树，进入其<strong>第一个存在右子树的祖先节点的右子树</strong>。（这就是为什么我们要沿着左子树往下走，并把沿途的右子树都压入栈中的原因）<ul>
<li>如果不存在有右子树的祖先节点祖先节点（即栈空了），结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>中序遍历回顾：</p>
<ul>
<li>尝试进入当前节点左子树<ul>
<li>如果当前节点存在左子树，进入其左子树，回到开头。</li>
<li>如果当前节点不存在左子树，<strong>访问当前节点</strong>，并尝试进入当前节点右子树<ul>
<li>如果当前节点存在右节点，进入右节点，回到开头。</li>
<li>如果当前节点不存在右子树，访问<strong>第一个将其作为左子树的祖先节点</strong>(即后继节点。对于存在右子树的节点，其后继节点为其右子树中最左节点。对于不存在右子的节点，其后继为第一个将其作为左子树的祖先节点。由于一般的二叉树节点设计中，都不提供进入父节点的指针。因此，我们在使用辅助栈的中序遍历的程序中，要一直沿着左子树走，并把经历的节点压入栈中。这些节点都是以后的【第一个将其作为左子树的祖先节点】)<ul>
<li>如果不存在将其作为左子树的祖先节点(即栈空了)，结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一个节点的【后继节点】是：</p>
<ul>
<li>如果这个节点的<strong>右子树非空</strong>，【后继节点】是右子树中的最小节点（右子树中一直沿着左走到头）</li>
<li>如果这个节点的<strong>右子树是空的</strong>，【后继节点】就是第一个把该节点当作左孩子的祖先节点（有可能不存在）。</li>
</ul>
<p>一个节点的【前序节点】是：</p>
<ul>
<li>如果这个节点的<strong>左子树非空</strong>，【前序节点】就是左子树中的最大节点（左子树中一直沿着右走到头）</li>
<li>如果这个节点的<strong>左子树是空的</strong>,【前序节点】就是第一个把该节点当作右孩子的祖先节点（有可能不存在）。</li>
</ul>
<p>前序与后继关系的相互性：一个节点n如果是另一个节点m的<strong>前序节点</strong>，那么节点m一定是n的<strong>后继节点</strong>。</p>
<p>二叉搜索树的中序遍历可以排序输出树中所有元素。所以中序遍历的过程，就是一个不断寻找当前节点的<strong>后继节点</strong>的过程。</p>
<p>当我们从根节点一路向左，沿路设置所有节点的<strong>前序节点</strong>的右孩子指针为该节点（等同于每个节点的后继节点设置为其右孩子，但是我们在当前节点处不能这么，因为会失去其右指针）。寻找每个节点的前驱节点时，当且仅当我们遇到树的最左边节点时，才会有<strong>左子树是空的</strong>的情况。并且该该节点不存在【前驱节点】（因为我们一路往左下来的）。之后打印该节点并进入该节点的右子树重复上面的过程。同时，在进入右子树时，所有比右子树里小的（右子树的所有前置节点）都被访问过了，这个时候如果再遇到<strong>左子树是空的</strong>的情况，我们也可以认为不存在【前驱节点】了，直接访问即可。然后再进入右子树的过程中，就可能发生顺着之前被设置的右孩子指针进入【后继节点】的情况，这个时候要重新检查该【后继节点】的前驱节点是不是自己，是自己就恢复原状，否则死循环。</p>
<p>思路（从根节点开始）</p>
<ul>
<li>如果该节点没有左孩子，访问该节点，进入该节点的右孩子</li>
<li>如果该节点有左孩子，寻找该节点的【前序节点】<ul>
<li>如果该节点的【前序节点】的右孩子是该节点本身<ul>
<li>访问该节点。</li>
<li>设置该节点的【前序节点】的右孩子为空。</li>
<li>进入该节点的右孩子。</li>
</ul>
</li>
<li>如果该节点的【前序节点】的右孩子为空<ul>
<li>设置该节点的【前序节点】的右孩子为该节点。</li>
<li>进入该节点的左孩子。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// no left child, we cannot find its predecessor</span></span><br><span class="line">            <span class="comment">// just visit it</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// root has a left child, we have to find its</span></span><br><span class="line">            <span class="comment">// predecessor and link them together</span></span><br><span class="line">            <span class="keyword">auto</span> pre = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right &amp;&amp; pre-&gt;right != root)</span><br><span class="line">            &#123;</span><br><span class="line">                pre = pre-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// situation1. we have never link root's </span></span><br><span class="line">            <span class="comment">// predecessor with it</span></span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;right = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// situation2. we have already linked, time to visit.</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                <span class="comment">// there is no need to move left anymore</span></span><br><span class="line">                <span class="comment">// we have just came back from its left</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h3 id="Morris前序遍历"><a href="#Morris前序遍历" class="headerlink" title="Morris前序遍历"></a>Morris前序遍历</h3><p>调整访问节点的位置，从【该前驱节点已经被访问过】移动到【该前去节点还未被访问过】，即是前序遍历。<br>思路（从根节点开始）</p>
<ul>
<li>如果该节点没有左孩子，访问该节点，进入该节点的右孩子</li>
<li>如果该节点有左孩子，寻找该节点的【前序节点】<ul>
<li>如果该节点的【前序节点】的右孩子是该节点本身<ul>
<li>设置该节点的【前序节点】的右孩子为空。</li>
<li>进入该节点的右孩子。</li>
</ul>
</li>
<li>如果该节点的【前序节点】的右孩子为空<ul>
<li>访问该节点。</li>
<li>设置该节点的【前序节点】的右孩子为该节点。</li>
<li>进入该节点的左孩子。<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">auto</span> result = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> pre = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;right != root) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(pre-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    result.push_back(root-&gt;val);</span><br><span class="line">                    pre-&gt;right = root;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Morris后序遍历"><a href="#Morris后序遍历" class="headerlink" title="Morris后序遍历"></a>Morris后序遍历</h3><p>Morris后序遍历需要设置一个哨兵节点，使这个哨兵节点的左孩子为树的根节点，右孩子为空。<br>思路（从哨兵节点开始）</p>
<ul>
<li>如果该节点没有左孩子，访问该节点，进入该节点的右孩子</li>
<li>如果该节点有左孩子，寻找该节点的【前序节点】<ul>
<li>如果该节点的【前序节点】的右孩子是该节点本身<ul>
<li><strong>逆序</strong>访问该节点的左孩子到该节点的【前序节点】</li>
<li>设置该节点的【前序节点】的右孩子为空。</li>
<li>进入该节点的右孩子。</li>
</ul>
</li>
<li>如果该节点的【前序节点】的右孩子为空<ul>
<li>设置该节点的【前序节点】的右孩子为该节点。</li>
<li>进入该节点的左孩子。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">auto</span> result = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> sentinel = <span class="keyword">new</span> TreeNode(INT_MAX);</span><br><span class="line">        sentinel-&gt;left = root;</span><br><span class="line">        root = sentinel;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> pre = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right &amp;&amp; pre-&gt;right != root) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(pre-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    pre-&gt;right = root;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//visit start</span></span><br><span class="line">                    <span class="keyword">auto</span> s = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">                    <span class="keyword">auto</span> pre2 = root-&gt;left;</span><br><span class="line">                    <span class="keyword">while</span>(pre2 != root)&#123;</span><br><span class="line">                        s.push(pre2-&gt;val);</span><br><span class="line">                        pre2 = pre2-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">                        result.push_back(s.top());</span><br><span class="line">                        s.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//visit end</span></span><br><span class="line">                    pre-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p>参考：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/484f587c967c" target="_blank" rel="noopener">面试算法：二叉树的Morris遍历算法 - 望月从良 - 简书</a><br><a href="https://ghh3809.github.io/2018/08/06/morris-traversal/" target="_blank" rel="noopener">经典算法小评(2)——Morris树遍历算法 - 风之筝 - GitHub Pages</a> <strong>有图解！</strong><br><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html" target="_blank" rel="noopener">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）- AnnieKim - 博客园</a> <strong>有图解！</strong></p>
</blockquote>
<hr>
<h1 id="二叉树的BFS"><a href="#二叉树的BFS" class="headerlink" title="二叉树的BFS"></a>二叉树的BFS</h1><p><em>层序遍历经常犯的错误：<code>for</code>循环不要写成<code>i &lt; queue.size()</code>，这样就失去记录<code>level_size</code>的意义了。</em></p>
<p>剑指Offer 32<br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LC102 Binary Tree Level Order Traversal</a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">LC107 Binary Tree Level Order Traversal II</a></p>
<p>类似BFS，我们维护一个队列，每次从队列里取出一个节点，然后再将该节点的左右孩子（如果有）再push进队列里即可。</p>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LC102</a>和<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">LC107</a>都要求将结果分层放入vector中，因此我们需要统计<strong>下一层有几个节点</strong>和<strong>这层还剩下多少节点</strong>。</p>
<p>因为层序遍历保证不遍历完当前层不会去遍历下一层：</p>
<ul>
<li>每次往队列里推入节点时，都是下一层的节点，这时我们就增加下一层节点计数器。</li>
<li>当前层节点计数器不等于0。每次我们从队列中取出节点时，都是当前层的节点，减少当前层节点计数器。</li>
<li>当前层节点计数器为0。将下一层节点计数器的值赋给当前层节点计数器，下一层计数器清零，继续循环。<br>实现细节注意：</li>
<li>换层时别忘了下层计数器清零。</li>
<li>换层时还要检查一下下一层计数器是否为0，如果为0，就不需要换层了。这里如果忘了检查的话，会多给结果在最后构造一个空数组。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        更清晰的代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">// if the tree is empty, return empty.</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="built_in">queue</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res&#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="comment">// push the root into the queue</span></span><br><span class="line">        <span class="built_in">queue</span>.push(root);</span><br><span class="line">        <span class="comment">// the nodes left in current level</span></span><br><span class="line">        <span class="keyword">size_t</span> cur_nums = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// the nodes in next level</span></span><br><span class="line">        <span class="keyword">size_t</span> next_nums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="built_in">queue</span>.front();</span><br><span class="line">            <span class="built_in">queue</span>.pop();</span><br><span class="line">            <span class="comment">// decrease the nodes in current level</span></span><br><span class="line">            --cur_nums;</span><br><span class="line">            <span class="comment">// push the node val into res</span></span><br><span class="line">            res.back().push_back(root-&gt;val);</span><br><span class="line">            <span class="comment">// push the left and right children into the queue</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(root-&gt;left);</span><br><span class="line">                ++next_nums;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">queue</span>.push(root-&gt;right);</span><br><span class="line">                ++next_nums;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check if cur level is empty </span></span><br><span class="line">            <span class="comment">// check if next level is not empty</span></span><br><span class="line">            <span class="keyword">if</span>(cur_nums == <span class="number">0</span> &amp;&amp; next_nums != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// change cur_nums into next_nums</span></span><br><span class="line">                cur_nums = next_nums;</span><br><span class="line">                <span class="comment">// next_nums reset</span></span><br><span class="line">                next_nums = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// create new "level" in the res vector</span></span><br><span class="line">                res.emplace_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2019年8月的代码
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> q = <span class="built_in">queue</span>&lt;TreeNode* &gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">size_t</span> nodes_in_next_level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> nodes_left_in_this_level = <span class="number">1</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.front();</span><br><span class="line">            <span class="comment">//visit cur</span></span><br><span class="line">            <span class="keyword">if</span>(nodes_left_in_this_level &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                v.back().push_back(cur-&gt;val);</span><br><span class="line">                --nodes_left_in_this_level;<span class="comment">//更新这层剩下的节点数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//nodes_left_in_this_level == 0，换到下一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                nodes_left_in_this_level = nodes_in_next_level - <span class="number">1</span>;</span><br><span class="line">                nodes_in_next_level = <span class="number">0</span>;</span><br><span class="line">                v.push_back(&#123;cur-&gt;val&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//visit end</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                q.push(cur-&gt;left);</span><br><span class="line">                ++nodes_in_next_level;<span class="comment">//统计下一层有几个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                q.push(cur-&gt;right);</span><br><span class="line">                ++nodes_in_next_level;<span class="comment">//统计下一层有几个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><p><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">LC662 二叉树的最大宽度</a></p>
<p>层序遍历二叉树。层序遍历时，每次遍历完一层，队列的长度就正好是下一层的节点树。在队列中不但记录节点，也记录下来节点的编号。类似二叉堆那样，一个节点编号为<code>idx</code>，他的左孩子编号是<code>2 * idx</code>，右孩子编号是<code>2 * idx + 1</code>。记录下每一层的第一个节点和最后一个节点的编号。他们的差就是这一层的宽度。</p>
<p>注意：这个题有一个全是左子树的测试用例，会导致编号溢出。所以我们每次都把编号”归一化”一下，让下一层的所有idx都统一减去一个值，就可以抑制序号的增长速度，也不会影响距离的计算。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">queue</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>.push(&#123;root, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// after processing a whole level</span></span><br><span class="line">            <span class="comment">// the num of nodes in next level is the size of queue</span></span><br><span class="line">            <span class="keyword">int</span> first_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> last_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> level_size = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; level_size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// get a node from the queue</span></span><br><span class="line">                <span class="keyword">auto</span> [node, idx] = <span class="built_in">queue</span>.front();</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line">                <span class="comment">// save the idx of first and last node</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) first_idx = idx;</span><br><span class="line">                <span class="keyword">if</span>(i == level_size - <span class="number">1</span>) last_idx = idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// push its children into the queue</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push(&#123;node-&gt;left, </span><br><span class="line">                    <span class="number">2</span> * idx - first_idx + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push(&#123;node-&gt;right, </span><br><span class="line">                    <span class="number">2</span> * idx + <span class="number">1</span> - first_idx + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// the whole level is processed, compute the width</span></span><br><span class="line">            width = max((last_idx - first_idx + <span class="number">1</span>), width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">LC199 二叉树的右视图</a><br>层次遍历，每次都把每一层最后一个节点的值放进结果容器中即可。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="comment">// we a level order traversal</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="built_in">queue</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// at the beginning of each iteration, queue size</span></span><br><span class="line">            <span class="comment">// is the number of nodes in this level</span></span><br><span class="line">            <span class="keyword">auto</span> level_size = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="comment">// pop the queue, push their children back</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_size ; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                root = <span class="built_in">queue</span>.front();</span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push(root-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push(root-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// root is now the last element in this level</span></span><br><span class="line">            <span class="comment">// , which is visible in the right sideview</span></span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="二叉树左下角的值"><a href="#二叉树左下角的值" class="headerlink" title="二叉树左下角的值"></a>二叉树左下角的值</h2><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">LC513 找树左下角的值</a><br>层次遍历，储存每层第一个节点即可。<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; <span class="built_in">queue</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>.push(root);</span><br><span class="line">        TreeNode* bottomLeftNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> level_size = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; level_size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                root = <span class="built_in">queue</span>.front();</span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left) <span class="built_in">queue</span>.push(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right) <span class="built_in">queue</span>.push(root-&gt;right);</span><br><span class="line">                <span class="comment">// save the first node in each level</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bottomLeftNode = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bottomLeftNode-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<h2 id="Zigzag遍历"><a href="#Zigzag遍历" class="headerlink" title="Zigzag遍历"></a>Zigzag遍历</h2><p>剑指Offer 32<br><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal</a></p>
<p>思路：</p>
<ul>
<li>利用栈的FIFO特点来实现每一层的逆序</li>
<li>用一个栈来存储当前层的节点，另一个栈存储下一层的节点。如果当前层的栈空了，交换两个栈。</li>
<li>不能只用一个栈，因为那样会使得下一层的节点先于这一层的节点被访问。</li>
<li>先把根节点入栈当前层</li>
<li>奇数层先入栈右孩子，偶数层先入栈左孩子</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> curStack = <span class="keyword">new</span> <span class="built_in">stack</span>&lt;TreeNode* &gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> nextStack = <span class="keyword">new</span> <span class="built_in">stack</span>&lt;TreeNode* &gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> result = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> odd_even_flag = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">size_t</span> nodes_in_next_level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> nodes_left_in_this_level = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        curStack-&gt;push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!curStack-&gt;empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = curStack-&gt;top();</span><br><span class="line">            <span class="comment">//visit cur</span></span><br><span class="line">            <span class="keyword">if</span>(nodes_left_in_this_level &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                result.back().push_back(cur-&gt;val);</span><br><span class="line">                --nodes_left_in_this_level;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nodes_left_in_this_level = nodes_in_next_level - <span class="number">1</span>;</span><br><span class="line">                nodes_in_next_level = <span class="number">0</span>;</span><br><span class="line">                result.push_back(&#123;cur-&gt;val&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//end visit</span></span><br><span class="line">            <span class="keyword">if</span>(odd_even_flag)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    nextStack-&gt;push(cur-&gt;left);</span><br><span class="line">                    ++nodes_in_next_level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    nextStack-&gt;push(cur-&gt;right);</span><br><span class="line">                    ++nodes_in_next_level;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    nextStack-&gt;push(cur-&gt;right);</span><br><span class="line">                    ++nodes_in_next_level;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    nextStack-&gt;push(cur-&gt;left);</span><br><span class="line">                    ++nodes_in_next_level;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;           </span><br><span class="line">            curStack-&gt;pop();</span><br><span class="line">            <span class="keyword">if</span>(curStack-&gt;empty()) &#123;</span><br><span class="line">                swap(curStack, nextStack);</span><br><span class="line">                odd_even_flag = !odd_even_flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> curStack;</span><br><span class="line">        <span class="keyword">delete</span> nextStack;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="层序下一节点"><a href="#层序下一节点" class="headerlink" title="层序下一节点"></a>层序下一节点</h2><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">LC116 填充每个节点的下一个右侧节点指针</a></p>
<p>思路一：<br>层序遍历。用queue.size()和for循环来定位每一层的开始和结束。记录前一个节点的指针，不断将前一个节点的指针设置为当前节点。但是这样做不满足题目空间复杂度为$O(1)$的要求。</p>
<p>层序遍历经常犯的错误：<code>for</code>循环不要写成<code>i &lt; queue.size()</code>，这样就失去记录<code>level_size</code>的意义了。<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; <span class="built_in">queue</span>&#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> level_size = <span class="built_in">queue</span>.size();</span><br><span class="line">            Node* preNode = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; level_size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = <span class="built_in">queue</span>.front();</span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) <span class="built_in">queue</span>.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right) <span class="built_in">queue</span>.push(cur-&gt;right);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(preNode) preNode-&gt;next = cur;</span><br><span class="line">                preNode = cur;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<hr>
<p>思路二：<br>利用完美二叉树的性质：<br>一个节点的左孩子的next必然是其右节点。一个节点的右孩子的next是该节点next的左孩子。从根节点开始，不断设置下一层的next指针。再移动到下一层的<em>最左侧</em>，因为此时这一层的next指针已经在上层被设置好，所以可以用这层的next设置下一层的next。循环直到最后一层即可。空间复杂度为$O(1)$满足题目要求。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> rt = root;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> first = root;</span><br><span class="line">            <span class="keyword">while</span>(root-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">                root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">            root = first-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">LC117 填充每个节点的下一个右侧节点指针II</a></p>
<p>同上题，取消了完美二叉树的假设。</p>
<p>一个节点的左孩子的next：</p>
<ul>
<li>如果有右孩子，则是右孩子</li>
<li>如果没有右孩子，则是该节点的右侧(next, next的next, …)的一个有孩子节点的第一个孩子。</li>
</ul>
<p>一个节点的右孩子的next：</p>
<ul>
<li>该节点的右侧(next, next的next, …)的一个有孩子节点的第一个孩子。</li>
</ul>
<p>下一层的第一个节点是：</p>
<ul>
<li>如果这一层的第一个节点有左孩子，是其左孩子</li>
<li>否则，如果这一层的第一个节点有右孩子，是其右孩子</li>
<li>否则，是该节点的右侧(next, next的next, …)的一个有孩子节点的第一个孩子。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> rt = root;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> first = root;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">                    root-&gt;right-&gt;next = child_next(root);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    root-&gt;left-&gt;next = child_next(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    root-&gt;right-&gt;next = child_next(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else !root-&gt;left &amp;&amp; !root-&gt;right do nothing</span></span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(first-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                root = first-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(first-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                root = first-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            root = child_next(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node* <span class="title">child_next</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root = root-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="完全二叉树插入器"><a href="#完全二叉树插入器" class="headerlink" title="完全二叉树插入器"></a>完全二叉树插入器</h2><p><a href="https://leetcode-cn.com/problems/complete-binary-tree-inserter/" target="_blank" rel="noopener">LC919 完全二叉树插入器</a></p>
<ul>
<li>维护一个队列。该队列类似层序遍历二叉树时的队列。</li>
<li>队列前端的节点一定是当前树中左右孩子还未被填满的最左侧节点。</li>
<li>每次向树中插入新节点时：<ul>
<li>检查队列首节点是否有左孩子，如果没有就将新节点插入到左孩子的位置，并把新节点放入队列</li>
<li>如果有左孩子，且该节点还在队列中，则该节点必然没有右孩子，将新节点放在队列该节点的右孩子处。把新节点放入队列。将该节点从队列中删掉。</li>
</ul>
</li>
<li><p>从最初给定的树构建队列时：</p>
<ul>
<li>从左到右层序遍历给定的树</li>
<li>如果左孩子或右孩子有一个缺失，就把该节点放入队列</li>
</ul>
</li>
<li><p>既然叫插入器，那么由调用该插入器的一方保证管理资源。</p>
</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CBTInserter(TreeNode* root) </span><br><span class="line">    :m_root&#123;root&#125;</span><br><span class="line">    ,m_parent&#123;&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        build_queue(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_queue</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> bfs_queue = <span class="built_in">queue</span>&lt;TreeNode*&gt;&#123;&#125;;</span><br><span class="line">        bfs_queue.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!bfs_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = bfs_queue.front();</span><br><span class="line">            bfs_queue.pop();</span><br><span class="line">            <span class="keyword">if</span>(!(node-&gt;left &amp;&amp; node-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                m_parent.push(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                bfs_queue.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                bfs_queue.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> parent = m_parent.front();</span><br><span class="line">        <span class="keyword">if</span>(!parent-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;left = <span class="keyword">new</span> TreeNode&#123;v&#125;;</span><br><span class="line">            m_parent.push(parent-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!parent-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            parent-&gt;right = <span class="keyword">new</span> TreeNode&#123;v&#125;;</span><br><span class="line">            m_parent.push(parent-&gt;right);</span><br><span class="line">            m_parent.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parent-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">get_root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* m_root;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; m_parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CBTInserter* obj = new CBTInserter(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;insert(v);</span></span><br><span class="line"><span class="comment"> * TreeNode* param_2 = obj-&gt;get_root();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="层数最深叶子节点的和"><a href="#层数最深叶子节点的和" class="headerlink" title="层数最深叶子节点的和"></a>层数最深叶子节点的和</h2><p><a href="https://xyfu.me/posts/e85d694a/#%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C">LC1302 层数最深叶子节点的和</a></p>
<p>层序遍历，记录每一层的和即可。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deepestLeavesSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> bfs_queue = <span class="built_in">queue</span>&lt;TreeNode*&gt;&#123;&#125;;</span><br><span class="line">        bfs_queue.push(root);</span><br><span class="line">        <span class="keyword">auto</span> level_size = <span class="keyword">size_t</span>&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!bfs_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur_level_size = <span class="keyword">size_t</span>&#123;&#125;;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; level_size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = bfs_queue.front();</span><br><span class="line">                bfs_queue.pop();</span><br><span class="line"></span><br><span class="line">                sum += node-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    bfs_queue.push(node-&gt;left);</span><br><span class="line">                    ++cur_level_size;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    bfs_queue.push(node-&gt;right);</span><br><span class="line">                    ++cur_level_size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            level_size = cur_level_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="二叉树的坐标化"><a href="#二叉树的坐标化" class="headerlink" title="二叉树的坐标化"></a>二叉树的坐标化</h1><p>利用一个有序数对$(x,y)$来确定二叉树中的每一个节点：</p>
<ul>
<li>根节点的坐标为$(0,0)$</li>
<li>一个节点的坐标为$(x,y)$，则其左孩子为$(x + 1, 2y)$，右孩子为$(x + 1, 2y + 1)$</li>
<li>一个非根节点的坐标为$(x,y)$，则其父节点的坐标为$(x - 1, \lfloor{\frac{y}{2}}\rfloor)$</li>
</ul>
<p><a href="https://xyfu.me/posts/e85d694a/#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E7%9A%84%E5%8F%B6%E8%8A%82%E7%82%B9">LC742 二叉树最近的叶节点</a>也可以通过坐标化来求距离。但其测试用例中有层数过多的二叉树，导致坐标溢出。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        overflow code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree_index</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">index</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> x;</span><br><span class="line">        <span class="keyword">size_t</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function">index <span class="title">left_child</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;x + <span class="number">1</span>, y * <span class="number">2</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">index <span class="title">right_child</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;x + <span class="number">1</span>, y * <span class="number">2</span> + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">index <span class="title">parent</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;x - <span class="number">1</span>, y / <span class="number">2</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;index&gt; down_path() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;*<span class="keyword">this</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> path = <span class="built_in">vector</span>&lt;index&gt;(x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">auto</span> idx = *<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i = path.rbegin(); i != path.rend(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                *i = idx;</span><br><span class="line">                idx = idx.parent();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> size_t <span class="title">distance</span><span class="params">(<span class="keyword">const</span> index&amp; lhs, <span class="keyword">const</span> index&amp; rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> lpath = lhs.down_path();</span><br><span class="line">            <span class="keyword">auto</span> rpath = rhs.down_path();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// get the iterators for lowest common ancestor</span></span><br><span class="line">            <span class="keyword">auto</span> [llca, rlca] = mismatch(lpath.begin(), lpath.end(), rpath.begin(), rpath.end(),</span><br><span class="line">            [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; l, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> l.x == r.x &amp;&amp; l.y == r.y;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (lpath.end() - llca) + (rpath.end() - rlca);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">tree_index</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">    :m_target_val&#123;target&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_indices[root] = index&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        tree_index_impl(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closest_leaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = UINT32_MAX;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> leaf : m_leaf_nodes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;"form: "&lt;&lt;leaf-&gt;val&lt;&lt;" "&lt;&lt;m_indices[leaf].x&lt;&lt;","&lt;&lt;m_indices[leaf].y&lt;&lt;" to "</span></span><br><span class="line">            <span class="comment">// &lt;&lt;m_indices[m_target].x&lt;&lt;","&lt;&lt;m_indices[m_target].y&lt;&lt;"\n";</span></span><br><span class="line">            <span class="keyword">auto</span> d = index::distance(m_indices[leaf], m_indices[m_target]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dist &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                dist = d;</span><br><span class="line">                res = leaf-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tree_index_impl</span><span class="params">(TreeNode* root)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == m_target_val)</span><br><span class="line">        &#123;</span><br><span class="line">            m_target = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            m_leaf_nodes.insert(root);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            m_indices[root-&gt;left] = m_indices[root].left_child();</span><br><span class="line">            tree_index_impl(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            m_indices[root-&gt;right] = m_indices[root].right_child();</span><br><span class="line">            tree_index_impl(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, index&gt; m_indices = &#123;&#125;;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; m_leaf_nodes = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span>       m_target_val = <span class="number">0</span>;</span><br><span class="line">    TreeNode* m_target = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClosestLeaf</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tidx = tree_index&#123;root, k&#125;;</span><br><span class="line">        <span class="keyword">return</span> tidx.closest_leaf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">LC987 二叉树的垂序遍历</a></p>
<p>按要求将二叉树所有节点坐标化后排序。再将排序好的数组按X坐标分割即可。<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> point&amp; lhs, <span class="keyword">const</span> point&amp; rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.x != rhs.x ? </span><br><span class="line">                   lhs.x &lt;  rhs.x :</span><br><span class="line">                   lhs.y != rhs.y ?</span><br><span class="line">                   lhs.y &gt;  rhs.y :</span><br><span class="line">                   lhs.val &lt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;point&gt; m_points;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_points.push_back(point&#123;<span class="number">0</span>, <span class="number">0</span>, root-&gt;val&#125;);</span><br><span class="line">        build_map(root, m_points.back());</span><br><span class="line"></span><br><span class="line">        sort(m_points.begin(), m_points.end());</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_points.begin(); it != m_points.end(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> last = it;</span><br><span class="line">            <span class="keyword">while</span>(last != m_points.end() &amp;&amp; last-&gt;x == it-&gt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                ++last;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.emplace_back(last - it);</span><br><span class="line">            transform(it, last, res.back().begin(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pt.val;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            it = last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_map</span><span class="params">(TreeNode* root, point pt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            m_points.push_back(point&#123;pt.x - <span class="number">1</span>, pt.y - <span class="number">1</span>, root-&gt;left-&gt;val&#125;);</span><br><span class="line">            build_map(root-&gt;left, m_points.back());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            m_points.push_back(point&#123;pt.x + <span class="number">1</span>, pt.y - <span class="number">1</span>, root-&gt;right-&gt;val&#125;);</span><br><span class="line">            build_map(root-&gt;right, m_points.back());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<h2 id="输出二叉树"><a href="#输出二叉树" class="headerlink" title="输出二叉树"></a>输出二叉树</h2><p><a href="https://leetcode-cn.com/problems/print-binary-tree/" target="_blank" rel="noopener">LC655 输出二叉树</a></p>
<p>先观察给的例子，我们可以发现：</p>
<ul>
<li>输出的数组行数为二叉树的最大深度depth，列数为二叉树的width = 2 ^ depth - 1。</li>
<li>先构造这么大的一个数组，并给他填充好空字符串<code>&quot;&quot;</code></li>
<li>根节点必然位于第0层的中央，也就是其坐标为<code>[0][width / 2]</code>;</li>
<li>再观察从第1层开始，每个节点和其父节点的间隔为diff = 2 ^ (depth - cur_level - 1)。</li>
<li>因此我们如果有了父节点的坐标，就可以直接推出其左右孩子的坐标。</li>
<li>那么我们就在这个树上做一个层序遍历就可以了。层序遍历用的队列储存<code>pair&lt;TreeNode*, int&gt;</code>，其中的int为这个node在这一行的坐标。</li>
<li>每次从队伍中取出节点，就根据他的坐标给他放入矩阵相应位置。然后再检查他的左右孩子，如果有的话，再根据他自己的坐标算出孩子的坐标。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; printTree(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">// we first find the depth of the given tree</span></span><br><span class="line">        <span class="keyword">auto</span> depth = depthTree(root);</span><br><span class="line">        <span class="comment">// width = 2 ^ depth - 1</span></span><br><span class="line">        <span class="keyword">auto</span> width = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; depth; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            width *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --width;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we create a matrix that is just the size of </span></span><br><span class="line">        <span class="comment">// the result and fill it in properly</span></span><br><span class="line">        <span class="keyword">auto</span> res = </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;(depth, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(width, <span class="string">""</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we start to do level order traversal on the tree</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="comment">// the pos for root should resides at the middle of the </span></span><br><span class="line">        <span class="comment">// first row, which is width / 2</span></span><br><span class="line">        <span class="built_in">queue</span>.push(&#123;root, width / <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="comment">// the distance between a node and its parent</span></span><br><span class="line">        <span class="comment">// could be computed by the following formula</span></span><br><span class="line">        <span class="comment">// diff = 2 ^ (depth - cur_level - 1)</span></span><br><span class="line">        <span class="comment">// we could initilize the level1 distance and</span></span><br><span class="line">        <span class="comment">// then divide it by 2 at the end of every level</span></span><br><span class="line">        <span class="keyword">int</span> diff = (width + <span class="number">1</span>) / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_level_size = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_level_size; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// take a node from the queue</span></span><br><span class="line">                <span class="keyword">auto</span> [node, idx] = <span class="built_in">queue</span>.front();</span><br><span class="line">                <span class="built_in">queue</span>.pop();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// put the node into its right pos</span></span><br><span class="line">                res[cur_level][idx] = to_string(node-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push(&#123;node-&gt;left, idx - diff&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push(&#123;node-&gt;right, idx + diff&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            diff = diff / <span class="number">2</span>;</span><br><span class="line">            ++cur_level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(depthTree(root-&gt;left), </span><br><span class="line">                   depthTree(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="二叉树的序列化"><a href="#二叉树的序列化" class="headerlink" title="二叉树的序列化"></a>二叉树的序列化</h1><h2 id="序列化与反序列化二叉树"><a href="#序列化与反序列化二叉树" class="headerlink" title="序列化与反序列化二叉树"></a>序列化与反序列化二叉树</h2><p>剑指Offer 37, <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">LC297 Serialize and Deserialize Binary Tree</a></p>
<p>序列化：用前序遍历来进行序列化，每次遇到空指针的时候，用$符号来占位。</p>
<p>反序列化：遍历序列化的字符串，也是用递归的方法，模拟前序遍历。只不过这会我们需要传递一个指针的指针。C++里用指针的指针不如用指针的引用方便。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        string_view版本 2020.6.18
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> DELIM    = <span class="string">','</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> NULLNODE = <span class="string">'$'</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> m_tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serializeImpl</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            m_tree += NULLNODE;</span><br><span class="line">            m_tree += DELIM;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_tree += to_string(root-&gt;val);</span><br><span class="line">        m_tree += DELIM;</span><br><span class="line"></span><br><span class="line">        serializeImpl(root-&gt;left);</span><br><span class="line">        serializeImpl(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        serializeImpl(root);</span><br><span class="line">        <span class="keyword">return</span> m_tree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string_view data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> first = data.begin();</span><br><span class="line">        <span class="keyword">return</span> deserialize(first, data.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(It&amp; first, It last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// check if it is a null node</span></span><br><span class="line">        <span class="keyword">if</span>(*first == NULLNODE)</span><br><span class="line">        &#123;</span><br><span class="line">            first += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it is not a null node, then it must has a value</span></span><br><span class="line">        <span class="comment">// decode and extract it value</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> val = [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> start = first;</span><br><span class="line">            <span class="keyword">while</span>(*first != DELIM)</span><br><span class="line">            &#123;</span><br><span class="line">                ++first;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> val = <span class="keyword">int</span>&#123;&#125;;</span><br><span class="line">            from_chars(&amp;*start, &amp;*first, val);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move the first iterator one step further to skip</span></span><br><span class="line">        <span class="comment">// the delimiter</span></span><br><span class="line">        ++first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this recursively on its left and right subtrees</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode&#123;val&#125;;</span><br><span class="line">        root-&gt;left = deserialize(first, last);</span><br><span class="line">        root-&gt;right = deserialize(first, last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        采用迭代器实现的版本
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">char</span> DELIMITER = <span class="string">','</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">char</span> NULLMARK  = <span class="string">'$'</span>;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// use preorder traversal sequence to serialize the tree</span></span><br><span class="line">        <span class="comment">// we have to mark the nullptrs with some special char</span></span><br><span class="line">        <span class="built_in">string</span> res&#123;&#125;;</span><br><span class="line">        serialize(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to avoid constructing too many some strings</span></span><br><span class="line">    <span class="comment">// we pass the ref of the string</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) </span><br><span class="line">        &#123;</span><br><span class="line">            res += NULLMARK;</span><br><span class="line">            res += DELIMITER;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res += to_string(root-&gt;val);</span><br><span class="line">        res += DELIMITER;</span><br><span class="line">        serialize(root-&gt;left, res);</span><br><span class="line">        serialize(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = data.begin();</span><br><span class="line">        <span class="keyword">return</span> deserialize(it, data.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(It&amp; it, It end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// nothing to deserilize</span></span><br><span class="line">        <span class="keyword">if</span>(it == end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// get a part from the stirng.</span></span><br><span class="line">        <span class="keyword">auto</span> start = it;</span><br><span class="line">        <span class="keyword">while</span>(*it != DELIMITER) ++it;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(start, it)</span></span>;</span><br><span class="line">        <span class="comment">// skip the delimiter</span></span><br><span class="line">        ++it;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if str is a nullptr</span></span><br><span class="line">        <span class="keyword">if</span> (*str.begin() == NULLMARK) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// if it is not NULLMARK, then it must be an integer</span></span><br><span class="line">        <span class="keyword">int</span> val = stoi(str);</span><br><span class="line">        <span class="comment">// create a TreeNode</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode&#123;val&#125;;</span><br><span class="line">        root-&gt;left = deserialize(it, end);</span><br><span class="line">        root-&gt;right = deserialize(it, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2019年8月实现的code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">string</span>&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> result = <span class="built_in">string</span>&#123;&#125;;</span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode*)&gt; serializeImpl;</span><br><span class="line">        serializeImpl = [&amp;serializeImpl, &amp;result](TreeNode* root)&#123;</span><br><span class="line">            result += to_string(root-&gt;val);</span><br><span class="line">            result += <span class="string">","</span>;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left) result += <span class="string">"$,"</span>;</span><br><span class="line">            <span class="keyword">else</span>            serializeImpl(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;right) result += <span class="string">"$,"</span>;</span><br><span class="line">            <span class="keyword">else</span>            serializeImpl(root-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        serializeImpl(root);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = data.begin();</span><br><span class="line">        <span class="keyword">auto</span> end = data.end();</span><br><span class="line">        <span class="keyword">auto</span> result = <span class="keyword">static_cast</span>&lt;TreeNode*&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">auto</span>&amp; root = result;</span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode*&amp;)&gt; deserializeImpl;  </span><br><span class="line">        deserializeImpl = [&amp;it, &amp;end, &amp;deserializeImpl](TreeNode*&amp; root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it == end) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">auto</span> begin = it;            </span><br><span class="line">            <span class="keyword">while</span>(*it != <span class="string">','</span>) ++it;</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">if</span>(*begin == <span class="string">'$'</span>)&#123;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                root = <span class="keyword">new</span> TreeNode&#123;stoi(<span class="built_in">string</span>(begin, it))&#125;;</span><br><span class="line">                ++it; </span><br><span class="line">            &#125;</span><br><span class="line">            deserializeImpl(root-&gt;left);  </span><br><span class="line">            deserializeImpl(root-&gt;right);  </span><br><span class="line">        &#125;;</span><br><span class="line">        deserializeImpl(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="序列化与反序列化N叉树"><a href="#序列化与反序列化N叉树" class="headerlink" title="序列化与反序列化N叉树"></a>序列化与反序列化N叉树</h2><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-n-ary-tree/" target="_blank" rel="noopener">LC428 序列化和反序列化 N 叉树</a></p>
<p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">LC297 Serialize and Deserialize Binary Tree</a>的升级版。区别在于每一个节点的孩子节点数目<code>node-&gt;children.size()</code>是不一定的。我们不但需要记录该节点的值，还需要记录该节点孩子的数目。同样采用前序遍历来序列化。再用前序遍历来反序列化。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> DELIM = <span class="string">','</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> NULLNODE = <span class="string">'$'</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">string</span>&#123;&#125;;</span><br><span class="line">        serialize_impl(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize_impl</span><span class="params">(Node* root, <span class="built_in">string</span>&amp; encode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            encode += NULLNODE;</span><br><span class="line">            encode += DELIM;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// encode the value with the number of children.</span></span><br><span class="line">        encode += to_string(root-&gt;val);</span><br><span class="line">        encode += DELIM;</span><br><span class="line">        encode += to_string(root-&gt;children.size());</span><br><span class="line">        encode += DELIM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> child : root-&gt;children)</span><br><span class="line">        &#123;</span><br><span class="line">            serialize_impl(child, encode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">Node* <span class="title">deserialize</span><span class="params">(string_view data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> first = data.begin();</span><br><span class="line">        <span class="keyword">return</span> deserialize(first, data.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node* <span class="title">deserialize</span><span class="params">(It&amp; first, It last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*first == NULLNODE)</span><br><span class="line">        &#123;</span><br><span class="line">            first += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> read_int = [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> val = <span class="keyword">int</span>&#123;&#125;;</span><br><span class="line">            <span class="keyword">auto</span> [delim, errc] = from_chars(&amp;*first, &amp;*last, val);</span><br><span class="line">            first += (delim - &amp;*first) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read twice, one for the value, one for the number of</span></span><br><span class="line">        <span class="comment">// children </span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> val = read_int();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> children_num = read_int();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> Node&#123;val&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; children_num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;children.push_back(deserialize(first, last));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="根据前序和中序遍历序列重建"><a href="#根据前序和中序遍历序列重建" class="headerlink" title="根据前序和中序遍历序列重建"></a>根据前序和中序遍历序列重建</h2><p>剑指Offer 7, <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">LC105 Construct Binary Tree from Preorder and Inorder Traversal</a></p>
<ul>
<li>前序遍历序列中，根节点一定是第一个数字</li>
<li>中序遍历序列中，根节点位于中间，其左边是其左子树的中序遍历序列，右边是其右子树的中序遍历序列<br>思路：</li>
<li>找根节点：我们用前序遍历序列的第一个数字在中序遍历序列中的位置。同时我们也知道了左右子树节点的数量。</li>
<li>找左右子树的遍历前序遍历序列：根据左右子树节点的数量确认。</li>
<li>在其左右子树上递归的调用</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder.begin(), preorder.end(), inorder.begin(), inorder.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(It first1, It last1, It first2, It last2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(first1 &lt; last1) || !(first2 &lt; last2)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the first node must be the root of the tree in preoreder tra</span></span><br><span class="line">        <span class="comment">// find this in the inorder tra</span></span><br><span class="line">        <span class="keyword">auto</span> rootIt = find(first2, last2, *first1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the size of its left subtree</span></span><br><span class="line">        <span class="keyword">auto</span> leftTreeSize = rootIt - first2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the last It for its left subtree</span></span><br><span class="line">        <span class="keyword">auto</span> last1_left = first1 + leftTreeSize + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a node for root</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode&#123;*rootIt&#125;;</span><br><span class="line">        root-&gt;left  = buildTree(first1 + <span class="number">1</span>, last1_left, first2, rootIt);</span><br><span class="line">        root-&gt;right = buildTree(last1_left, last1, rootIt + <span class="number">1</span>, last2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preoder.empty() || inorder.empty())</span><br><span class="line">        <span class="keyword">return</span> buildTreeImpl(preorder.begin(), preorder.end(), inorder.begin(), inorder.end());        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeImpl</span><span class="params">(It pbegin, It pend, It ibegin, It iend)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pbegin == pend) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> proot = pbegin;</span><br><span class="line">        <span class="keyword">auto</span> iroot = find(ibegin, iend, *proot);</span><br><span class="line">        <span class="keyword">auto</span> leftTreeNumber = distance(ibegin, iroot);</span><br><span class="line">        <span class="keyword">auto</span> rightTreeNumber = distance(iroot,iend);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> leftpbegin = proot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> leftpend = leftpbegin + leftTreeNumber;     </span><br><span class="line">        <span class="keyword">auto</span> rightpbegin = leftpend;</span><br><span class="line">        <span class="keyword">auto</span> rightpend = pend;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> leftibegin = ibegin;</span><br><span class="line">        <span class="keyword">auto</span> leftiend = iroot;</span><br><span class="line">        <span class="keyword">auto</span> rightibegin = iroot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> rightiend = iend;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> leftChild  = buildTreeImpl(leftpbegin, leftpend, leftibegin, leftiend);</span><br><span class="line">        <span class="keyword">auto</span> rightChild = buildTreeImpl(rightpbegin, rightpend, rightibegin, rightiend);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> rootNode = <span class="keyword">new</span> TreeNode&#123;*proot&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftChild)  rootNode-&gt;left = leftChild;</span><br><span class="line">        <span class="keyword">if</span>(rightChild) rootNode-&gt;right = rightChild;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="根据后序和中序遍历序列重建"><a href="#根据后序和中序遍历序列重建" class="headerlink" title="根据后序和中序遍历序列重建"></a>根据后序和中序遍历序列重建</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">LC106 Construct Binary Tree from Inorder and Postorder Traversal</a><br>思路同上，不同点在于</p>
<ul>
<li>后序遍历的根节点是最后一个</li>
</ul>
<p>代码去掉了中间变量<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder.begin(), inorder.end(), postorder.begin(), postorder.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(It first1, It last1, It first2, It last2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// invariance last1 - first1 == last2 - first2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// there is no node left in range, just return nullptr</span></span><br><span class="line">        <span class="keyword">if</span>(!(first1 &lt; last2) || !(first2 &lt; last2))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the root of the tree must be the last </span></span><br><span class="line">        <span class="comment">// node of postorder traversal sequence</span></span><br><span class="line">        --last2;</span><br><span class="line">        <span class="comment">// find this root in the inorder traversal sequence</span></span><br><span class="line">        <span class="comment">// it must seperate the inorder traversal sequence into its left</span></span><br><span class="line">        <span class="comment">// and right subtree</span></span><br><span class="line">        <span class="keyword">auto</span> rootIt = find(first1, last1, *last2);</span><br><span class="line">        <span class="comment">// compute the size of its right subtree</span></span><br><span class="line">        <span class="keyword">auto</span> rightTreeSize = last1  - (rootIt + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// compute the last It for its left subtree in the postorder</span></span><br><span class="line">        <span class="comment">// traversal sequence.</span></span><br><span class="line">        <span class="keyword">auto</span> last2_left = last2 - rightTreeSize;</span><br><span class="line">        <span class="comment">// create a new TreeNode for this root</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode&#123;*rootIt&#125;;</span><br><span class="line"></span><br><span class="line">        root-&gt;left  = buildTree(first1, rootIt, first2, last2_left);</span><br><span class="line">        root-&gt;right = buildTree(rootIt + <span class="number">1</span>, last1, last2_left, last2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTreeImpl(postorder.begin(), postorder.end(), inorder.begin(), inorder.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeImpl</span><span class="params">(It pbegin, It pend, It ibegin, It iend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pbegin == pend) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> proot = pend - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> iroot = find(ibegin, iend, *proot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> leftTreeNumber = distance(ibegin, iroot);</span><br><span class="line">        <span class="keyword">auto</span> rightTreeNumber = distance(iroot + <span class="number">1</span>, iend);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">auto</span> rightChild = buildTreeImpl(proot - rightTreeNumber</span><br><span class="line">                                      ,proot</span><br><span class="line">                                      ,iroot + <span class="number">1</span></span><br><span class="line">                                      ,iend);</span><br><span class="line">        <span class="keyword">auto</span> leftChild = buildTreeImpl(pbegin</span><br><span class="line">                                      ,pbegin + leftTreeNumber</span><br><span class="line">                                      ,ibegin</span><br><span class="line">                                      ,iroot);</span><br><span class="line">        <span class="keyword">auto</span> rootNode = <span class="keyword">new</span> TreeNode&#123;*proot&#125;;</span><br><span class="line">        <span class="keyword">if</span>(leftChild) rootNode-&gt;left = leftChild;</span><br><span class="line">        <span class="keyword">if</span>(rightChild) rootNode-&gt;right = rightChild;</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<h1 id="二叉树的路径"><a href="#二叉树的路径" class="headerlink" title="二叉树的路径"></a>二叉树的路径</h1><h2 id="向下路径"><a href="#向下路径" class="headerlink" title="向下路径"></a>向下路径</h2><p>向下路径可以被定义为：从根节点出发到任一节点的一条路径。<br>叶子路径：从根节点出发到叶子节点的一条路径。</p>
<p>一个节点的向下路径可以是：</p>
<ul>
<li>仅包含该节点</li>
<li>包含该节点 和 其左子树的向下路径</li>
<li>包含该节点 和 其右子树的向下路径</li>
</ul>
<p>一个节点的<em>叶子路径</em>是（注意：不可以仅仅包含该节点）</p>
<ul>
<li>包含该节点 和 其左子树的向下路径</li>
<li>包含该节点 和 其右子树的向下路径</li>
</ul>
<hr>
<h2 id="二叉树的深度（最大叶子路径长度）"><a href="#二叉树的深度（最大叶子路径长度）" class="headerlink" title="二叉树的深度（最大叶子路径长度）"></a>二叉树的深度（最大叶子路径长度）</h2><p>剑指Offer 55, <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">LC104 Maximum Depth of Binary Tree</a></p>
<p>思路一：<br>求二叉树的最大深度，就是求二叉树中最大的叶子路径长度。</p>
<p>空节点的最大叶子路径长度为0<br>一个节点的最大叶子路径长度是 1 + max(左子树的最大叶子路径长度，右子树的最大叶子路径长度)</p>
<p>思路二：<br>定义：空树的深度为0。则二叉树的最大深度 = max(左子树的最大深度, 右子树的最大深度) + 1。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), </span><br><span class="line">                   maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="二叉树的最小深度（最小叶子路径长度）"><a href="#二叉树的最小深度（最小叶子路径长度）" class="headerlink" title="二叉树的最小深度（最小叶子路径长度）"></a>二叉树的最小深度（最小叶子路径长度）</h2><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">LC111 Minimum Depth of Binary Tree</a></p>
<p>思路一：<br>求二叉树的最小深度，就是求二叉树中最小的叶子路径长度。</p>
<p>一个节点的最小叶子路径长度是：</p>
<ul>
<li>空节点的最小叶子路径长度为0</li>
<li>如果左右子树有一个为空，则为 1 + 左子树最小叶子路径长度 + 右子树最小叶子路径长度：<ul>
<li>两个都为空，返回1</li>
<li>如果有一个为空，则返回 1 + 另一个</li>
</ul>
</li>
<li>如果左子树都不为空，则为 1 + min(左子树最小叶子路径长度, 右子树最小叶子路径长度)</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> l = minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = minDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + r + l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span> + min(l ,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p>思路二：<br>一个二叉树的最小深度等于</p>
<ul>
<li>如果没有左孩子，是右子树的最小深度+1</li>
<li>如果没有右孩子，是左子树的最小深度+1</li>
<li>如果左右孩子都有，是左右孩子的最小深度当中较小的一个+1</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> leftDepth = minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> rightDepth = minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftDepth == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        <span class="keyword">if</span>(rightDepth == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        <span class="keyword">return</span> leftDepth &lt; rightDepth ? leftDepth + <span class="number">1</span> : rightDepth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="向下路径和"><a href="#向下路径和" class="headerlink" title="向下路径和"></a>向下路径和</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">LC257 二叉树的所有路径</a><br><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">LC112 路径总和</a><br><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">LC113 路径总和II</a><br><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">LC437 路径总和III</a><br><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">LC129 根到叶子组成的数字</a></p>
<p>见<a href="https://xyfu.me/posts/f92eff5d/#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84">回溯#二叉树的路径</a></p>
<hr>
<p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">LC120 三角形最小路径和</a></p>
<p>思路一(TLE)：<br>回溯暴力找，TLE在预期之内。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> level_end;</span><br><span class="line">    <span class="keyword">int</span> min_sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.empty() || triangle.front().empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        level_end = triangle.size();</span><br><span class="line">        min_sum = INT_MAX;</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, triangle);</span><br><span class="line">        <span class="keyword">return</span> min_sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> idx, <span class="keyword">int</span> sum, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level == level_end)</span><br><span class="line">        &#123;</span><br><span class="line">            min_sum = min(min_sum, sum);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; idx + <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            backtrack(level + <span class="number">1</span>, i, sum + triangle[level][idx], triangle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p>思路二：<br>第l层中，第i个节点的最小路径和是：<code>dp[l][i] = triangle[l][i] + min(dp[l + 1][i], dp[l + 1][i + 1])</code>。可以看出这是一个动态规划问题。初始状态是当l为最后一层时，<code>dp[l][i] = triangle[l][i]</code>。从下到上填表即可。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(triangle.empty() || triangle.front().empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = ++triangle.rbegin(); it != triangle.rend(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; level =  *it;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; next_level = *(it - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; level.size(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                level[i] = level[i] + min(next_level[i], next_level[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> triangle.front().front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="折返路径"><a href="#折返路径" class="headerlink" title="折返路径"></a>折返路径</h2><p>折返路径是一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p>对于二叉树中的每一个节点，经过该节点的这种路径有四种（注意是向下路径，不是到达叶子节点的向下路径）</p>
<ul>
<li>仅包含该节点</li>
<li>包含该节点 和 其左子树中的一条<em>向下路径</em></li>
<li>包含该节点 和 其右子树中的一条<em>向下路径</em></li>
<li>包含该节点 和 其左子树中的一条<em>向下路径</em> 和 其右子树中的一条<em>向下路径</em></li>
</ul>
<p>可见，求折返路径的实质仍然是求向下路径。折返路径只不过是在每个节点，对其左右节点的向下路径的总结。因此大部分折返路径的问题，其递归函数的返回值仍然是向下路径的。</p>
<hr>
<h2 id="折返路径的长度"><a href="#折返路径的长度" class="headerlink" title="折返路径的长度"></a>折返路径的长度</h2><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">LC543 二叉树的直径</a></p>
<p>求二叉树中最长折返路径的长度 - 1。</p>
<p>思路1：遍历二叉树中所有节点，在每一个节点都计算一次其左子树和右子树的向下路径长度。二叉树的直径即是最大的【左子树向下路径 + 右子树向下路径】。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        diameter(root);</span><br><span class="line">        <span class="keyword">return</span> m_res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">diameter</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m_res = max</span><br><span class="line">        (</span><br><span class="line">            m_res,</span><br><span class="line">            down_path_size(root-&gt;left) + down_path_size(root-&gt;right)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        diameterOfBinaryTree(root-&gt;left);</span><br><span class="line">        diameterOfBinaryTree(root-&gt;right);       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">down_path_size</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(</span><br><span class="line">            <span class="number">1</span> + down_path_size(root-&gt;left),</span><br><span class="line">            <span class="number">1</span> + down_path_size(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p>思路2：<br>直接计算根节点的向下路径长即可。因为想要得到一个节点的向下路径长度，必然需要先得到其左右的向下路径长度。如果其左右子树的向下路径长度已知，我们就可以顺便算出该节点的直径长度。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        downPathLen(root);</span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">downPathLen</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> lDownPathLen = downPathLen(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> rDownPathLen = downPathLen(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        res = max(res, <span class="number">1</span> + lDownPathLen + rDownPathLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(lDownPathLen, rDownPathLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="最长同值折返路径"><a href="#最长同值折返路径" class="headerlink" title="最长同值折返路径"></a>最长同值折返路径</h2><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">LC687 最长同值路径</a></p>
<p>思路一：<br>找树中的最长同值折返路径，就是找树中所有节点的最长同值折返路径。</p>
<p>一个节点的最长同值折返路径是：</p>
<ul>
<li>初始化<code>len = 1</code></li>
<li>如果他和左孩子相等，len = len + 左孩子的最长同值向下路径</li>
<li>如果他和右孩子相等，len = len + 右孩子的最长同值向下路径</li>
</ul>
<p>一个节点的最长同值向下路径是：1 + max(左孩子的最长同值向下路径, 右孩子的最长同值向下路径)</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        longestUnivaluePath__(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">longestUnivaluePath__</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        longestUnivaluePath_(root);</span><br><span class="line">        longestUnivaluePath__(root-&gt;left);</span><br><span class="line">        longestUnivaluePath__(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath_</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            left = longestUnivaluePath_(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            right = longestUnivaluePath_(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res, left + right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p>思路二：</p>
<p>在思路一种我们用了递归套递归来完成计算，导致了大量的重复。我们思考修改程序的结构，只用一种递归来完成。<br>思路一中，计算向下路径的流程判断<code>root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val</code>和<code>root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val</code>阻断递归函数的向下传播，导致我们必须使用另一个递归函数来遍历所有树的节点。</p>
<p>之前提到过，折返路径的本质仍然是<em>向下路径</em>。折返路径只不过是在每个节点，对其左右节点的向下路径的总结。所以我们先想出<em>最长向下同值路径</em>该怎么写？然后再在其中添加上计算折返路径的程序段即可。可以观察到，下面的代码如果去掉求折返路径的程序段，就会变成一个求向下路径的递归函数。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        lup(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lup</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = lup(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = lup(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line">        <span class="keyword">auto</span> cur_path = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cur = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = max(cur, <span class="number">1</span> + left);</span><br><span class="line">            <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line">            cur_path += left;</span><br><span class="line">            <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = max(cur, <span class="number">1</span> + right);</span><br><span class="line">            <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line">            cur_path += right;</span><br><span class="line">            <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line">        res = max(res, cur_path);</span><br><span class="line">        <span class="comment">/* 求折返路径的程序段 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="折返路径和"><a href="#折返路径和" class="headerlink" title="折返路径和"></a>折返路径和</h2><p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">LC124 Binary Tree Maximum Path Sum</a></p>
<p>求二叉树中折返路径的最大路径和。思路类似动态规划中最大子数组和。</p>
<p>思路：要求所有折返路径的最大路径和，我们需要求<em>通过每一个节点</em>的折返路径的路径和的最大值。在求一个节点的折返路径和之前，我们需要知道其<em>左子树的向下路径</em>的路径和 和 其<em>右子树的向下路径</em>的路径和。因此考虑后续遍历（或者说是自然就写成了后续遍历）。</p>
<ul>
<li><p>如果该节点为空节点，不存在折返路径，向下路径和为0。</p>
</li>
<li><p>该节点的折返路径和 为 该节点的值 + max(左子树向下路径和最大值, 0) + max(右子树向下路径和最大值, 0)。因为折返路径可以是：</p>
<ul>
<li>仅包含该节点，即max(左子树向下路径和最大值, 0) = 0，且 max(右子树向下路径和最大值, 0) = 0。</li>
<li>包含该节点和左子树的向下路径，即max(左子树向下路径和最大值, 0) 不等于 0，但max(右子树向下路径和最大值, 0) = 0</li>
<li>包含该节点和右子树的向下路径，同理</li>
<li>包含该节点和左右子树的向下路径，即max(左子树向下路径和最大值, 0) 不等于 0 且 max(右子树向下路径和最大值, 0) 不等于 0</li>
<li>折返路径不可以不包含该节点，因为定义中要求：<em>该路径至少包含一个节点</em>。</li>
</ul>
</li>
<li><p>该节点的向下路径和 为 该节点的值 + max(左子树向下路径和最大值, 右子树向下路径和最大值)。</p>
</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = INT_MIN;</span><br><span class="line">        downPathSum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">downPathSum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> lDownPathSum = downPathSum(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> rDownPathSum = downPathSum(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        res = max(res, root-&gt;val + max(lDownPathSum, <span class="number">0</span>) + max(rDownPathSum, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + max(&#123;<span class="number">0</span>, lDownPathSum, rDownPathSum&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>剑指Offer 55, <a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">LC110 平衡二叉树</a></p>
<p>判断一个二叉树是否满足以下性质：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>思路一：</p>
<p>类似求折返路径的思路。</p>
<ul>
<li>递归函数求每个节点的叶子路径长度。</li>
<li>检查该节点的左孩子和右孩子的叶子路径长度差是否超过1。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res = <span class="literal">true</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = depth(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = depth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left - right &gt; <span class="number">1</span> || right - left &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res &amp;&amp; <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">1</span> + left, <span class="number">1</span> + right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="两个二叉树的关系"><a href="#两个二叉树的关系" class="headerlink" title="两个二叉树的关系"></a>两个二叉树的关系</h1><h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">LC100 相同的树</a></p>
<p>思路：设计程序同时遍历两个树。当一个指针是空指针时，也要求另一个指针也是空指针。之后检查值是否相等就可以。不传引用的版本要明显快一些。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        不传引用的版本
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((!p &amp;&amp; q) || (!q &amp;&amp; p)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// else, p &amp;&amp; q</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left)</span><br><span class="line">            &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        传引用的版本
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        isSameTree(p, q, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q, <span class="keyword">bool</span>&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!res) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>((p == <span class="literal">nullptr</span>) ^ (q == <span class="literal">nullptr</span>)) &#123;res = <span class="literal">false</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;res = <span class="literal">false</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        isSameTree(p-&gt;left, q-&gt;left, res);</span><br><span class="line">        isSameTree(p-&gt;right,q-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p>剑指Offer 26, [Acwing37 树的子结构]（<a href="https://www.acwing.com/problem/content/description/35/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/description/35/</a> ）<br><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">LC面试题26. 树的子结构</a></p>
<p>前一题相同的树的升级版。我们只需要遍历A树，找到和B树根节点的值相同的节点，然后在这里开始判断两个树是否相同。<br>注意：</p>
<pre><code>- 判例认为空树不是任何树的子树
- 不能简单的复制前一题的isSameTree。因为**A树指针不为空，而B树指针为空**这种情况是允许的。但是不能**A为空，B不为空**。
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        recursive code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line">    TreeNode* A;</span><br><span class="line">    TreeNode* B;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A &amp;&amp; !B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((A &amp;&amp; !B) || (!A &amp;&amp; B)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A = A;</span><br><span class="line">        <span class="keyword">this</span>-&gt;B = B;</span><br><span class="line">        res = <span class="literal">false</span>;</span><br><span class="line">        dfs(A);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res || !root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == B-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res || unguarded_isSameTree(root, B);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unguarded_isSameTree</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A &amp;&amp; B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>( (!B &amp;&amp; A) || (!A &amp;&amp; !B) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;val != B-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unguarded_isSameTree(A-&gt;left, B-&gt;left)  &amp;&amp;</span><br><span class="line">               unguarded_isSameTree(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        stack code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>&#123;&#125;;</span><br><span class="line">        <span class="comment">// do a preorder traversal</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(A)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if we find nodes have the same value, check from there</span></span><br><span class="line">                <span class="keyword">if</span>(A-&gt;val == B-&gt;val </span><br><span class="line">                    &amp;&amp; unguarded_isSameTree(A, B))</span><br><span class="line">                    <span class="keyword">goto</span> found;</span><br><span class="line">                <span class="built_in">stack</span>.push_back(A-&gt;right);</span><br><span class="line">                A = A-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>.empty()) <span class="keyword">break</span>;</span><br><span class="line">            A = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    found:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unguarded_isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!q &amp;&amp; p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> unguarded_isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;</span><br><span class="line">               unguarded_isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2019年8月的思路和code
    </div>
    <div class='spoiler-content'>
        <p>被搜索的树叫s,另一个叫t<br>思路：</p>
<ul>
<li>首先遍历第一个树，找到和第二个树根节点值相同的节点。</li>
<li>从这里开始遍历两个树。<ul>
<li>如果<code>t == nullptr</code>，返回<code>true</code>，不需要管s是不是空。</li>
<li>如果<code>t != nullptr &amp;&amp; s == nullptr</code>返回<code>false</code></li>
<li>如果t和s节点的值不同，返回false</li>
<li>继续搜索左子树和右子树。return 左 &amp;&amp; 右。</li>
</ul>
</li>
</ul>
<p>注意：这个题的判例会很奇怪的认为空的树不是另一个树的子树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()</span><br><span class="line">    :result(<span class="literal">false</span>)</span><br><span class="line">    ,t(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;</span><br><span class="line">        result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = pRoot2;</span><br><span class="line">        hasSubtreeImpl1(pRoot1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> result;</span><br><span class="line">    TreeNode* t;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hasSubtreeImpl1</span><span class="params">(TreeNode* s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val == t-&gt;val)    result = hasSubtreeImpl2(s, t);</span><br><span class="line">        <span class="keyword">if</span>(!result &amp;&amp; s-&gt;left)  hasSubtreeImpl1(s-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(!result &amp;&amp; s-&gt;right) hasSubtreeImpl1(s-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasSubtreeImpl2</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(s-&gt;val == t-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> hasSubtreeImpl2(s-&gt;left, t-&gt;left) &amp;&amp; hasSubtreeImpl2(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">LC572 Subtree of Another Tree</a><br><a href="https://leetcode-cn.com/problems/check-subtree-lcci/" target="_blank" rel="noopener">LC面试题04.10 检查子树</a><br>这个题和剑指Offer 26的题不同，这个题要求【子结构】不能是原来的树的一部分，必须从根节点开始，所有子节点一模一样，不能多，也不能少。修改一下判断是否相同的函数就可以了</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2020.6.20 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; t2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;val == t2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> is_same_tree(t1, t2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> checkSubTree(t1-&gt;left, t2) || checkSubTree(t1-&gt;right, t2); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_same_tree</span><span class="params">(TreeNode* r1, TreeNode* r2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r1 &amp;&amp; !r2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((!r1 &amp;&amp; r2) || (r1 &amp;&amp; !r2)</span><br><span class="line">        || (r1-&gt;val != r2-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> is_same_tree(r1-&gt;left, r2-&gt;left) &amp;&amp; is_same_tree(r1-&gt;right, r2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2020.6.18 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        isSubtree_impl(s, t);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isSubtree_impl</span><span class="params">(TreeNode* s, TreeNode* t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(res || !s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val == t-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            res = is_same_tree(s, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!res)</span><br><span class="line">        &#123;</span><br><span class="line">            isSubtree_impl(s-&gt;left, t);</span><br><span class="line">            isSubtree_impl(s-&gt;right, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto is_same_tree(TreeNode* s, TreeNode* t) -&gt; bool</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((!s &amp;&amp; !t))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((!s &amp;&amp; t) || (!t &amp;&amp; s)</span><br><span class="line">        || (s-&gt;val != t-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> is_same_tree(s-&gt;left , t-&gt;left) </span><br><span class="line">        &amp;&amp;     is_same_tree(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> result = <span class="literal">false</span>;</span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode*)&gt; isSubTreeImpl1;</span><br><span class="line">        function&lt;<span class="keyword">bool</span>(TreeNode*, TreeNode*)&gt; isSubTreeImpl2;</span><br><span class="line">        </span><br><span class="line">        isSubTreeImpl1 = [&amp;isSubTreeImpl1, &amp;isSubTreeImpl2, &amp;result, t](TreeNode* root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == t-&gt;val)&#123;result = isSubTreeImpl2(root, t);&#125;</span><br><span class="line">            <span class="keyword">if</span>(!result &amp;&amp; root-&gt;left)  isSubTreeImpl1(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(!result &amp;&amp; root-&gt;right) isSubTreeImpl1(root-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        isSubTreeImpl2 = [&amp;isSubTreeImpl2](TreeNode* s, TreeNode* t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t &amp;&amp; !s) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//修改这里！</span></span><br><span class="line">            <span class="keyword">if</span>(!t || !s) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//修改这里！</span></span><br><span class="line">            <span class="keyword">if</span>(s-&gt;val != t-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> isSubTreeImpl2(s-&gt;left, t-&gt;left) &amp;&amp; isSubTreeImpl2(s-&gt;right, t-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        isSubTreeImpl1(s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">LC617 合并二叉树</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// both of them are nullptr, nothing to do</span></span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// if one of them is a nullptr, the value of the new</span></span><br><span class="line">        <span class="comment">// node will be the one that is not nullptr</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1 &amp;&amp; !t2)</span><br><span class="line">        &#123;</span><br><span class="line">            val = t1-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!t1 &amp;&amp; t2)</span><br><span class="line">        &#123;</span><br><span class="line">            val = t2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// (t1 &amp;&amp; t2)</span></span><br><span class="line">        &#123;</span><br><span class="line">            val = t1-&gt;val + t2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a new node</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode&#123;val&#125;;</span><br><span class="line">        <span class="comment">// recursively call and create</span></span><br><span class="line">        </span><br><span class="line">        root-&gt;left = mergeTrees(leftNode(t1),leftNode(t2));</span><br><span class="line">        root-&gt;right = mergeTrees(rightNode(t1), rightNode(t2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> TreeNode* <span class="title">leftNode</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? root-&gt;left : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> TreeNode* <span class="title">rightNode</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? root-&gt;right : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><h3 id="求一个二叉树的镜像："><a href="#求一个二叉树的镜像：" class="headerlink" title="求一个二叉树的镜像："></a>求一个二叉树的镜像：</h3><p>剑指Offer 27, <a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">LC226 Invert Binary Tree</a><br>homebrew作者写不出来的代码。遍历过程中交换二叉树的左孩子和右孩子指针即可。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        root-&gt;left = invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;right = invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h3 id="判断两个树为镜像-判断一个树对称-："><a href="#判断两个树为镜像-判断一个树对称-：" class="headerlink" title="判断两个树为镜像(判断一个树对称)："></a>判断两个树为镜像(判断一个树对称)：</h3><p>剑指Offer 28, <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">LC101 Symmertic Tree</a> </p>
<p>使用我们在迭代后序遍历二叉树时的技巧：对称的前序遍历。如果一棵树的对称前序遍历和前序遍历相同，那么这棵树是对称的。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        res = <span class="literal">true</span>;</span><br><span class="line">        isSymmetric(root, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* A, TreeNode* B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!res || (!A &amp;&amp; !B)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>((!A &amp;&amp; B) || (!B &amp;&amp; A) || (A-&gt;val != B-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isSymmetric(A-&gt;left, B-&gt;right);</span><br><span class="line">        isSymmetric(A-&gt;right, B-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="树中两个节点的最低公共祖先"><a href="#树中两个节点的最低公共祖先" class="headerlink" title="树中两个节点的最低公共祖先"></a>树中两个节点的最低公共祖先</h1><h2 id="二叉搜索树的最低公共祖先"><a href="#二叉搜索树的最低公共祖先" class="headerlink" title="二叉搜索树的最低公共祖先"></a>二叉搜索树的最低公共祖先</h2><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">LC235 Lowest Common Ancestor of a Binary Search Tree</a></p>
<ul>
<li>如果当前节点比两个节点的值都小，搜索当前节点的右子树。</li>
<li>如果当前节点比两个节点的值都大，搜索当前节点的左子树。</li>
<li>如果当前节点在两个节点确定的闭区间中，返回当前节点。</li>
</ul>
<p>（如果保证BST里没有重复节点可以这么写，如果BST里有重复节点，那就很麻烦了）</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="二叉树的最低公共祖先"><a href="#二叉树的最低公共祖先" class="headerlink" title="二叉树的最低公共祖先"></a>二叉树的最低公共祖先</h2><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LC236 Lowest Common Ancestor of a Binary Tree</a></p>
<p>不像二叉搜索树一样，节点的值之间有一定的规律。在向下路径当中我们曾经提到：从根节点到树中某一节点的向下路径是唯一的。我们需要找到从根节点到两个节点的向下路径。之后在其中找都首个不匹配的元素，其公共祖先即为首个不匹配的元素前一个元素。如果不存在不匹配的元素，说明这两个节点是完全一样的。首个不匹配的元素前一个元素即为该节点，符合题目要求。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; cur_path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; p_path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; q_path;</span><br><span class="line">    TreeNode* p;</span><br><span class="line">    TreeNode* q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == q) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;p = p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;q = q;</span><br><span class="line"></span><br><span class="line">        backtrack(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [it1, it2] = mismatch(p_path.begin(), p_path.end(), q_path.begin());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *(--it1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        cur_path.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == p)</span><br><span class="line">        &#123;</span><br><span class="line">            p_path = cur_path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root == q)</span><br><span class="line">        &#123;</span><br><span class="line">            q_path = cur_path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrack(root-&gt;left);</span><br><span class="line">        backtrack(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        cur_path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="二叉树的最近叶节点"><a href="#二叉树的最近叶节点" class="headerlink" title="二叉树的最近叶节点"></a>二叉树的最近叶节点</h2><p><a href="https://leetcode-cn.com/problems/closest-leaf-in-a-binary-tree/" target="_blank" rel="noopener">LC742 二叉树的最近叶节点</a></p>
<p>一个节点A到另一个节点B的距离，即是A到B的路径的长度。为了求路径的长度，我们需要找到折返点。注意到根节点到任何节点的向下路径是唯一的。因此：</p>
<ul>
<li>找到根节点到A和B的向下路径</li>
<li>用<code>std::mismatch</code>找到首个在A和B中的向下路径中不匹配的位置<code>pa, pb</code></li>
<li>计算<code>pa</code>到A向下路径末尾的长度+<code>pb</code>到B向下路径末尾的长度，其和即为路径长度。</li>
</ul>
<p>思路：</p>
<ul>
<li>遍历二叉树，记录下目标节点和所有叶子节点的向下路径。</li>
<li>计算目标节点到所有叶子节点的距离。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; m_path_map = &#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; m_path = &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m_target = <span class="number">0</span>;</span><br><span class="line">    TreeNode* m_target_node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">size_t</span> m_min_dist = UINT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> m_res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findClosestLeaf</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        m_target = k;</span><br><span class="line">        build_path(root);</span><br><span class="line">        closest_leaf();</span><br><span class="line">        <span class="keyword">return</span> m_res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_path</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_path.push_back(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        || root-&gt;val == m_target)</span><br><span class="line">        &#123;</span><br><span class="line">            m_path_map[root] = m_path;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val == m_target)</span><br><span class="line">            &#123;</span><br><span class="line">                m_target_node = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        build_path(root-&gt;left);</span><br><span class="line">        build_path(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        m_path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">closest_leaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : m_path_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.first-&gt;val != m_target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">auto</span> dist = distance(m_target_node, p.first);</span><br><span class="line">                    m_min_dist &gt; dist)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_res = p.first-&gt;val;</span><br><span class="line">                    m_min_dist = dist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p.first-&gt;left &amp;&amp; !p.first-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                m_min_dist = <span class="number">0</span>;</span><br><span class="line">                m_res = p.first-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> distance(TreeNode* lhs, TreeNode* rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lpath = m_path_map[lhs];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; rpath = m_path_map[rhs];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [lp, rp] = mismatch(lpath.begin(), lpath.end(), rpath.begin(), rpath.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (lpath.end() - lp) + (rpath.end() - rp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p>见<a href="https://xyfu.me/posts/e8eb0481/#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">二分查找#困难二分查找##完全二叉树的节点个数</a></p>
<h1 id="二叉树的边界"><a href="#二叉树的边界" class="headerlink" title="二叉树的边界"></a>二叉树的边界</h1><p><a href="https://leetcode-cn.com/problems/boundary-of-binary-tree/" target="_blank" rel="noopener">LC545 二叉树的边界</a></p>
<p>左边界和右边界的定义比较复杂：</p>
<ul>
<li>在左子树存在时总是优先访问，如果不存在左子树则访问右子树。重复以上操作，首先抵达的结点就是最左侧结点。</li>
<li>左边界的定义是从根到最左侧结点的路径。</li>
<li>若根没有左子树，则根自身就是左边界。</li>
</ul>
<p>找出左边界，右边界和下边界（即所有叶子结点）后，由于左边界和右边界中可能包含有叶子结点，因此会出现重复节点。去掉这些重复节点即可。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; m_leftpath;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; m_rightpath;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; m_bottompath;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; boundaryOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        [=]()<span class="keyword">mutable</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_leftpath.push_back(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                m_leftpath.push_back(root);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        [=]()<span class="keyword">mutable</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                m_rightpath.push_front(root);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        preorder(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clean duplicate nodes</span></span><br><span class="line">        <span class="keyword">if</span>(m_leftpath.back() == m_bottompath.front())</span><br><span class="line">        &#123;</span><br><span class="line">            m_leftpath.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_bottompath.back() == m_rightpath.front())</span><br><span class="line">        &#123;</span><br><span class="line">            m_bottompath.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build the result</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> tsfm = [](<span class="keyword">auto</span> x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        transform(m_leftpath.begin(), m_leftpath.end(), back_inserter(res), tsfm);</span><br><span class="line">        transform(m_bottompath.begin(), m_bottompath.end(), back_inserter(res), tsfm);</span><br><span class="line">        transform(m_rightpath.begin(), m_rightpath.end(), back_inserter(res), tsfm);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            m_bottompath.push_back(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preorder(root-&gt;left);</span><br><span class="line">        preorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h1><h2 id="分裂子树的最大乘积"><a href="#分裂子树的最大乘积" class="headerlink" title="分裂子树的最大乘积"></a>分裂子树的最大乘积</h2><p>去掉一条边，将一棵树分成两颗树。其中一棵树以该边的子节点为根节点，很容易获得其节点和。为了得到另一棵树的节点和，我们需要先知道整个树的节点和，用整个树的节点和减去一边的节点和，即是另一边的节点和。</p>
<ul>
<li>统计所有子树的节点和。</li>
<li>根据均值不等式，找到和【整个树节点和】S一半最接近的节点和T。</li>
<li>所求结果即为S * (S - T)</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int64_t</span>&gt; m_sum = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sum = tree_sum(root);</span><br><span class="line">        <span class="keyword">auto</span> m1 = *min_element(m_sum.begin(), m_sum.end(), [a = sum / <span class="number">2.</span>](<span class="keyword">auto</span> lhs, <span class="keyword">auto</span> rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a - lhs) &lt; <span class="built_in">abs</span>(a - rhs);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (m1 * (sum - m1)) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> tree_sum(TreeNode* root)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> sum = root-&gt;val + tree_sum(root-&gt;left) + tree_sum(root-&gt;right);</span><br><span class="line">        m_sum.insert(sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="统计同值子树"><a href="#统计同值子树" class="headerlink" title="统计同值子树"></a>统计同值子树</h2><p><a href="https://leetcode-cn.com/problems/count-univalue-subtrees/" target="_blank" rel="noopener">LC250 统计同值子树</a></p>
<ul>
<li>一个树如果所有节点的值都相等，那么称其为<em>同值</em></li>
<li>空树一定是同值的，没有孩子的树一定是同值的</li>
<li>如果一个树的根节点满足下面所有条件，那么这颗树是同值的<ul>
<li>左子树是同值的，右子树也是同值的</li>
<li>根节点的值等于左孩子的值，也等于右孩子的值</li>
</ul>
</li>
<li>那么一个树的根节点满足下面任意条件，则不是同值的<ul>
<li>左子树 或 右子树不是同值</li>
<li>根节点的值不等于左孩子的值 或 根节点的值不等于右孩子的值</li>
</ul>
</li>
</ul>
<p>要求统计所有同值子树的个数。我们遍历所有节点，在所有节点处都判断以该节点为根的树是否为同值子树。记录同值子树的个数。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUnivalSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        countUnivalSubtrees_impl(root);</span><br><span class="line">        <span class="keyword">return</span> m_res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countUnivalSubtrees_impl</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_res += is_unival_tree(root);</span><br><span class="line">        countUnivalSubtrees(root-&gt;left);</span><br><span class="line">        countUnivalSubtrees(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_unival_tree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val)</span><br><span class="line">        || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> is_unival_tree(root-&gt;left) &amp;&amp; is_unival_tree(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p>改进：采用备忘录方式记录已经遍历过的节点是否为同值子树。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">bool</span>&gt; m_memo = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUnivalSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        countUnivalSubtrees_impl(root);</span><br><span class="line">        <span class="keyword">return</span> m_res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countUnivalSubtrees_impl</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> is_unival = is_unival_tree(root);</span><br><span class="line">        m_memo[root] = is_unival;</span><br><span class="line">        m_res += is_unival;</span><br><span class="line"></span><br><span class="line">        countUnivalSubtrees(root-&gt;left);</span><br><span class="line">        countUnivalSubtrees(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_unival_tree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val)</span><br><span class="line">        || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> is_unival_tree_memo(root-&gt;left) &amp;&amp;</span><br><span class="line">        is_unival_tree_memo(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto is_unival_tree_memo(TreeNode* root) -&gt; bool</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">auto</span> it = m_memo.find(root);</span><br><span class="line">        it == m_memo.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = is_unival_tree(root);</span><br><span class="line">            m_memo[root] = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="子树的最大平均值"><a href="#子树的最大平均值" class="headerlink" title="子树的最大平均值"></a>子树的最大平均值</h2><ul>
<li>平均值 = 所有节点的值的和 / 节点数</li>
<li>一棵树的平均值 = (根节点的值 + 左子树的节点和 + 右子树的节点和) / (1 + 左子树的节点数 + 右子树的节点数)</li>
<li>递归地在所有节点计算即可。也可采用备忘录记录已经算过的节点。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_res = <span class="number">0.</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maximumAverageSubtree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maximumAverageSubtree_impl(root);</span><br><span class="line">        <span class="keyword">return</span> m_res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">maximumAverageSubtree_impl</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> [s, n] = sum_and_num(root);</span><br><span class="line">        m_res = max(m_res, s / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(n));</span><br><span class="line">        maximumAverageSubtree_impl(root-&gt;left);</span><br><span class="line">        maximumAverageSubtree_impl(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto sum_and_num(TreeNode* root) -&gt; std::pair&lt;int, int&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [ls, ln] = sum_and_num(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [rs, rn] = sum_and_num(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> make_pair</span><br><span class="line">        (</span><br><span class="line">            ls + rs + root-&gt;val,</span><br><span class="line">            ln + rn + <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h1 id="在二叉树中分配硬币"><a href="#在二叉树中分配硬币" class="headerlink" title="在二叉树中分配硬币"></a>在二叉树中分配硬币</h1><p><a href="https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/" target="_blank" rel="noopener">LC979 在二叉树中分配硬币</a></p>
<ul>
<li>对于一个叶子节点：<ul>
<li>如果硬币数为0，必然通过父节点得到一枚硬币</li>
<li>如果硬币数大于1，必须通过父节点转移一枚硬币</li>
</ul>
</li>
<li>记一个子树的硬币不平衡数为b<ul>
<li>空树的不平衡数为0</li>
<li>非空树的不平衡数为：左子树的不平衡数 + 右子树的不平衡数 + (该树根节点的硬币数 - 1)</li>
</ul>
</li>
<li>通过该节点转移的硬币数为：|左子树的不平衡数| + |右子树的不平衡数|</li>
</ul>
<p>我们需要统计通过所有节点转移的硬币数。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_total_transfered = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        unbalance_coins(root);</span><br><span class="line">        <span class="keyword">return</span> m_total_transfered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unbalance_coins</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> lu = unbalance_coins(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> ru = unbalance_coins(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        m_total_transfered += <span class="built_in">abs</span>(lu) + <span class="built_in">abs</span>(ru);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lu + ru + root-&gt;val - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag"># 二叉树</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/2362a8ea/" rel="prev" title="链表">
      <i class="fa fa-chevron-left"></i> 链表
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/ef3a3fcc/" rel="next" title="字符串匹配">
      字符串匹配 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的DFS"><span class="nav-number">1.</span> <span class="nav-text">二叉树的DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#递归方法"><span class="nav-number">1.1.</span> <span class="nav-text">递归方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈"><span class="nav-number">1.2.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前序遍历"><span class="nav-number">1.2.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中序遍历"><span class="nav-number">1.2.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后续遍历"><span class="nav-number">1.2.3.</span> <span class="nav-text">后续遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Morris遍历"><span class="nav-number">1.3.</span> <span class="nav-text">Morris遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中序遍历-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Morris前序遍历"><span class="nav-number">1.3.2.</span> <span class="nav-text">Morris前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Morris后序遍历"><span class="nav-number">1.3.3.</span> <span class="nav-text">Morris后序遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的BFS"><span class="nav-number">2.</span> <span class="nav-text">二叉树的BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的最大宽度"><span class="nav-number">2.1.</span> <span class="nav-text">二叉树的最大宽度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的右视图"><span class="nav-number">2.2.</span> <span class="nav-text">二叉树的右视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树左下角的值"><span class="nav-number">2.3.</span> <span class="nav-text">二叉树左下角的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zigzag遍历"><span class="nav-number">2.4.</span> <span class="nav-text">Zigzag遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#层序下一节点"><span class="nav-number">2.5.</span> <span class="nav-text">层序下一节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完全二叉树插入器"><span class="nav-number">2.6.</span> <span class="nav-text">完全二叉树插入器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#层数最深叶子节点的和"><span class="nav-number">2.7.</span> <span class="nav-text">层数最深叶子节点的和</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的坐标化"><span class="nav-number">3.</span> <span class="nav-text">二叉树的坐标化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#输出二叉树"><span class="nav-number">3.1.</span> <span class="nav-text">输出二叉树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的序列化"><span class="nav-number">4.</span> <span class="nav-text">二叉树的序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化与反序列化二叉树"><span class="nav-number">4.1.</span> <span class="nav-text">序列化与反序列化二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化与反序列化N叉树"><span class="nav-number">4.2.</span> <span class="nav-text">序列化与反序列化N叉树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重建二叉树"><span class="nav-number">5.</span> <span class="nav-text">重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#根据前序和中序遍历序列重建"><span class="nav-number">5.1.</span> <span class="nav-text">根据前序和中序遍历序列重建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#根据后序和中序遍历序列重建"><span class="nav-number">5.2.</span> <span class="nav-text">根据后序和中序遍历序列重建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的路径"><span class="nav-number">6.</span> <span class="nav-text">二叉树的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#向下路径"><span class="nav-number">6.1.</span> <span class="nav-text">向下路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的深度（最大叶子路径长度）"><span class="nav-number">6.2.</span> <span class="nav-text">二叉树的深度（最大叶子路径长度）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的最小深度（最小叶子路径长度）"><span class="nav-number">6.3.</span> <span class="nav-text">二叉树的最小深度（最小叶子路径长度）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向下路径和"><span class="nav-number">6.4.</span> <span class="nav-text">向下路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#折返路径"><span class="nav-number">6.5.</span> <span class="nav-text">折返路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#折返路径的长度"><span class="nav-number">6.6.</span> <span class="nav-text">折返路径的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长同值折返路径"><span class="nav-number">6.7.</span> <span class="nav-text">最长同值折返路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#折返路径和"><span class="nav-number">6.8.</span> <span class="nav-text">折返路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平衡二叉树"><span class="nav-number">6.9.</span> <span class="nav-text">平衡二叉树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#两个二叉树的关系"><span class="nav-number">7.</span> <span class="nav-text">两个二叉树的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相同的树"><span class="nav-number">7.1.</span> <span class="nav-text">相同的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树的子结构"><span class="nav-number">7.2.</span> <span class="nav-text">树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并二叉树"><span class="nav-number">7.3.</span> <span class="nav-text">合并二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对称的二叉树"><span class="nav-number">7.4.</span> <span class="nav-text">对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#求一个二叉树的镜像："><span class="nav-number">7.4.1.</span> <span class="nav-text">求一个二叉树的镜像：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断两个树为镜像-判断一个树对称-："><span class="nav-number">7.4.2.</span> <span class="nav-text">判断两个树为镜像(判断一个树对称)：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树中两个节点的最低公共祖先"><span class="nav-number">8.</span> <span class="nav-text">树中两个节点的最低公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树的最低公共祖先"><span class="nav-number">8.1.</span> <span class="nav-text">二叉搜索树的最低公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的最低公共祖先"><span class="nav-number">8.2.</span> <span class="nav-text">二叉树的最低公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的最近叶节点"><span class="nav-number">8.3.</span> <span class="nav-text">二叉树的最近叶节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#完全二叉树的节点个数"><span class="nav-number">9.</span> <span class="nav-text">完全二叉树的节点个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的边界"><span class="nav-number">10.</span> <span class="nav-text">二叉树的边界</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#子树"><span class="nav-number">11.</span> <span class="nav-text">子树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分裂子树的最大乘积"><span class="nav-number">11.1.</span> <span class="nav-text">分裂子树的最大乘积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计同值子树"><span class="nav-number">11.2.</span> <span class="nav-text">统计同值子树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子树的最大平均值"><span class="nav-number">11.3.</span> <span class="nav-text">子树的最大平均值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在二叉树中分配硬币"><span class="nav-number">12.</span> <span class="nav-text">在二叉树中分配硬币</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xuanyi Fu</p>
  <div class="site-description" itemprop="description">Xuanyi Fu的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xuanyi-fu" title="GitHub → https://github.com/xuanyi-fu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5300073738" title="Weibo → https://weibo.com/5300073738" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xuanyi Fu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">131k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:59</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
