<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xyfu.me').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="指针使用前，一定要检查指针是否是nullptr。 善用dummyNode 链表操作三板斧：slice, transform, splice 裁剪，变换，拼接 裁剪下来的节点，一定要设置next为nullptr。  链表逆序：LC206 Reverse Linked List⚠️LC92 Reverse Linked List II[用dummyHead更容易处理m &#x3D;&#x3D; 0的情况]链表删除：LC">
<meta property="og:type" content="article">
<meta property="og:title" content="链表">
<meta property="og:url" content="http://xyfu.me/posts/2362a8ea/index.html">
<meta property="og:site_name" content="Xuanyi Fu Blog">
<meta property="og:description" content="指针使用前，一定要检查指针是否是nullptr。 善用dummyNode 链表操作三板斧：slice, transform, splice 裁剪，变换，拼接 裁剪下来的节点，一定要设置next为nullptr。  链表逆序：LC206 Reverse Linked List⚠️LC92 Reverse Linked List II[用dummyHead更容易处理m &#x3D;&#x3D; 0的情况]链表删除：LC">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-08-22T11:20:30.000Z">
<meta property="article:modified_time" content="2020-07-14T07:15:09.207Z">
<meta property="article:author" content="Xuanyi Fu">
<meta property="article:tag" content="链表">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xyfu.me/posts/2362a8ea/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>链表 | Xuanyi Fu Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xuanyi Fu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://xyfu.me/posts/2362a8ea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xuanyi Fu">
      <meta itemprop="description" content="Xuanyi Fu的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xuanyi Fu Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          链表
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-22 19:20:30" itemprop="dateCreated datePublished" datetime="2019-08-22T19:20:30+08:00">2019-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-14 15:15:09" itemprop="dateModified" datetime="2020-07-14T15:15:09+08:00">2020-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>8.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li>指针使用前，一定要检查指针是否是<code>nullptr</code>。</li>
<li>善用dummyNode</li>
<li>链表操作三板斧：slice, transform, splice 裁剪，变换，拼接</li>
<li>裁剪下来的节点，一定要设置<code>next</code>为<code>nullptr</code>。</li>
</ul>
<p>链表逆序：<br><a href="https://xyfu.me/posts/2362a8ea/#%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8">LC206 Reverse Linked List</a><br>⚠️<a href="https://xyfu.me/posts/2362a8ea/#%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8">LC92 Reverse Linked List II</a>[用dummyHead更容易处理m == 0的情况]<br>链表删除：<br><a href="https://xyfu.me/posts/2362a8ea/#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E9%97%AE%E9%A2%98">LC237 Delete Node in a Linked List</a>[靠拷贝后一个节点的val来做删除]<br><a href="https://xyfu.me/posts/2362a8ea/#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">LC19 Remove Nth Node From End of List</a>[无论如何也要遍历，裁拼]<br><a href="https://xyfu.me/posts/2362a8ea/#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E6%9C%89%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E8%8A%82%E7%82%B9">LC203 Remove Linked List Elements</a>[删除给定值的节点，裁拼]<br><a href="https://xyfu.me/posts/2362a8ea/#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">LC83 删除排序链表中的重复元素</a>[裁变拼]<br>⚠️<a href="https://xyfu.me/posts/2362a8ea/#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">LC82 删除排序链表中的重复元素II</a>[要求将重复元素全部清除，需要维护两个指针]<br>链表求环：<br><a href="https://xyfu.me/posts/2362a8ea/#%E6%89%BE%E5%87%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%8E%AF">LC141 Linked List Cycle</a><br><a href="https://xyfu.me/posts/2362a8ea/#%E6%89%BE%E5%87%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%8E%AF">LC142 Linked List Cycle II</a>[环长为相遇时慢指针移动的步数]<br><a href="https://xyfu.me/posts/2362a8ea/#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">LC287 Find the Duplicate Number</a>[相等的是first/slow，返回的也是first/slow]<br>链表归并/排序：<br><a href="https://xyfu.me/posts/2362a8ea/#%E5%90%88%E5%B9%B62%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">LC21 Merge Two Sorted Lists</a><br><a href="https://xyfu.me/posts/2362a8ea/#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">LC23 Merge k Sorted Lists</a><br><a href="https://xyfu.me/posts/2362a8ea/#%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">LC147 对链表进行插入排序</a><br>⚠️⚠️<a href="https://xyfu.me/posts/2362a8ea/#%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">LC148 排序链表</a><br>其他：<br>❌<a href="https://xyfu.me/posts/2362a8ea/#%E4%B8%A4%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8">LC24 两两交换链表中的节点</a><br>❌<a href="https://xyfu.me/posts/2362a8ea/#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">LC143 重排链表</a><br><a href="https://xyfu.me/posts/2362a8ea/#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">LC138 复杂链表复制</a><br><a href="https://xyfu.me/posts/2362a8ea/#%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8">LC725 分隔链表</a><br><a href="https://xyfu.me/posts/2362a8ea/#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">LC160 两个链表的公共节点</a><br>❌<a href="https://xyfu.me/posts/2362a8ea/#K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8">LC24 K个一组翻转链表</a><br><a href="https://xyfu.me/posts/cfca6522/#%E4%BB%8E%E9%93%BE%E8%A1%A8%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9">LC1171 从链表中删去总和为零的连续节点</a><br><a href="https://xyfu.me/posts/2362a8ea/#%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">LC430 扁平化多级双向链表</a></p>
<a id="more"></a>
<h1 id="STL中的链表"><a href="#STL中的链表" class="headerlink" title="STL中的链表"></a>STL中的链表</h1><ul>
<li>C++11 起有官方提供的单向链表了(forward_list)</li>
<li><p>STL中的list，提供以下的成员函数(member function)</p>
<ul>
<li>排序(<code>sort</code>)</li>
<li>归并(<code>merge</code>)</li>
<li><p>移除(<code>remove</code>/ <code>remove_if</code>) 和 类似移除的函数(<code>unique</code>)<br>  <code>&lt;algorithm&gt;</code>里面提供的非成员函数的<code>remove</code>只会把不想要的元素给挪动到容器的尾部，并返回一个指向<em>逻辑结尾</em>的迭代器。</p>
<blockquote>
<p>通过以满足不移除的元素出现在范围起始的方式，迁移（以移动赋值的方式）范围中的元素进行移除。保持剩余元素的相对顺序，且不更改容器的物理大小。指向范围的新逻辑结尾和物理结尾之间元素的迭代器仍然可解引用，但元素自身拥有未指定值（因为可移动赋值 (MoveAssignable) 的后置条件）。调用 remove 典型地后随调用容器的 erase 方法，它擦除未指定值并减小容器的物理大小，以匹配其新的逻辑大小。<br>  和<code>&lt;algorithm&gt;</code>里提供不同，list自己提供的<code>remove</code>会切切实实的把不想要的元素给删掉。</p>
</blockquote>
<p>  <strong>参考</strong></p>
<ul>
<li><a href="https://zh.cppreference.com/w/cpp/algorithm/remove" target="_blank" rel="noopener">cppreference.com: std::list::remove</a></li>
<li>Effective STL, Scott Meyer, Item 44 Prefer member functions to algorithms with the same names.</li>
<li>Effective STL, Scott Meyer, Item 32 Following remove-like algorithms by erase if you really want to remove them.</li>
<li><a href="https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom" target="_blank" rel="noopener">Wikipedia: Erase-remove idiom</a></li>
</ul>
</li>
</ul>
</li>
<li>不同STL中list的实现和哨兵节点(sentinel)<br>  <strong>TODO</strong></li>
</ul>
<h1 id="删除节点问题"><a href="#删除节点问题" class="headerlink" title="删除节点问题"></a>删除节点问题</h1><p>任何在这种暴露元素指针的容器里，直接通过指针来删除元素的方法都可能导致未定义行为。这些题就只是做做而已。对于释放申请来的内存的问题，一定要谨慎。尽量用智能指针。这个题目可以练习自己实现一个包裹的很好的链表<a href="https://leetcode.com/problems/design-linked-list/" target="_blank" rel="noopener">LC707 Design Linked List</a></p>
<h2 id="O-1-时间删除链表的一个给定节点"><a href="#O-1-时间删除链表的一个给定节点" class="headerlink" title="O(1)时间删除链表的一个给定节点"></a>O(1)时间删除链表的一个给定节点</h2><p><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">LC237 Delete Node in a Linked List</a></p>
<p>这个题目限定了：链表里至少有两个元素且被删除的元素不是末尾元素。为什么会有这样的限定？我们可以从<a href="https://www.acwing.com/problem/content/description/85/" target="_blank" rel="noopener">AcWing28 在O(1)时间删除链表结点</a>这个错误的题目看出来，并在剑指Offer 18来解决这个问题。</p>
<p>这个题目只提供了链表中要被删除的那个节点的指针。因为是单向链表，我们无法获取这个节点的前一个节点的指针，也就无法更改他前一个节点的<code>next</code>。一个简单的想法是，把当前节点的下一个节点的值拷给当前节点，然后再把当前节点next设置成下一个节点的next，最后不要忘了删除下一个节点。</p>
<p>这种复制数值的删除链表方法，仅适用于val的复制代价很小的情况，比如整个类的实现都被放在了一个指向其实现的指针的情况，即<em>pImpl idiom</em> 。详见<a href="https://zh.cppreference.com/w/cpp/language/pimpl" target="_blank" rel="noopener">cppreference: pImpl</a>.</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val; <span class="comment">//不需要判断：这个节点是空节点？</span></span><br><span class="line">        <span class="keyword">auto</span> tmp = node-&gt;next-&gt;next; <span class="comment">//不需要判断：这个节点的下一个节点是空节点？</span></span><br><span class="line">        <span class="keyword">delete</span> node-&gt;next;</span><br><span class="line">        node-&gt;next= tmp;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>【错误的题目】<a href="https://www.acwing.com/problem/content/description/85/" target="_blank" rel="noopener">AcWing28 在O(1)时间删除链表结点</a> 错在：这个题目没有提供头节点</p>
<p>这个题目没有任何限定，所以</p>
<ul>
<li>这个链表可能为空(<code>!node</code>)：什么都不做直接返回就可以了</li>
<li>这个节点可能是最后一个节点(<code>!(node-&gt;next)</code>，或链表只有一个节点)：把这个节点删除</li>
</ul>
<p>最后两个特殊情况会导致未定义行为(undefined behavior)。因为如果一旦删除头节点，头节点的指针指向的就是被释放的内存。同理，如果删除尾节点，尾节点的前一个节点的指针也将指向一块被释放的内存。如果像链表设计惯例里一样添加一个【哨兵节点】，会减少很多麻烦。<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        【错误的程序】但能AC
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            node = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        <span class="keyword">auto</span> tmp = node-&gt;next;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<p>剑指Offer 18</p>
<p>这个题目类似前面的<a href="https://www.acwing.com/problem/content/description/85/" target="_blank" rel="noopener">AcWing28 在O(1)时间删除链表结点</a>，但是提供了链表头节点的指针的指针。这个链表头节点可以用来解决被删节点是最后一个节点的问题。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode** ppHead, ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果链表为空或者被删除节点为空</span></span><br><span class="line">        <span class="keyword">if</span>(!ppHead||!(*ppHead)||!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果删除头节点</span></span><br><span class="line">        <span class="keyword">if</span>(node == *ppHead)&#123;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="comment">//这句话不需要了，因为node在return时就被销毁了。</span></span><br><span class="line">            <span class="comment">//node = nullptr </span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果删除的非尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next)&#123;</span><br><span class="line">            node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">auto</span> tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果删除尾节点</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//!(node-&gt;next)</span></span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">auto</span> pBeforeNode = *pHead;</span><br><span class="line">            <span class="keyword">while</span>(pBeforeNode-&gt;next != node) </span><br><span class="line">                pBeforeNode = pBeforeNode-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="comment">//这句话不需要了，因为node在return时就被销毁了。</span></span><br><span class="line">            <span class="comment">//node = nullptr </span></span><br><span class="line">            pBeforeNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div> 
<h2 id="删除链表中所有有给定值的节点"><a href="#删除链表中所有有给定值的节点" class="headerlink" title="删除链表中所有有给定值的节点"></a>删除链表中所有有给定值的节点</h2><p><a href="https://leetcode.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">LC203 Remove Linked List Elements</a><br>因为无论如何都要遍历链表，所以即使所有删除都是O(1)也不会使算法复杂度有所减少。所以按照处理链表的一般思路：</p>
<pre><code>- 从头上取下来一个节点
- 判断这个节点的val是不是等与val
    - 如果是就不拼接
    - 如果不是就给他拼到新链表上
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> np = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// backup</span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val != val)</span><br><span class="line">            &#123;</span><br><span class="line">                np-&gt;next = head;</span><br><span class="line">                np = np-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// forward</span></span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="删除链表中倒数第k个节点"><a href="#删除链表中倒数第k个节点" class="headerlink" title="删除链表中倒数第k个节点"></a>删除链表中倒数第k个节点</h2><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">LC19 Remove Nth Node From End of List</a><br>【这是一个有问题的题目】<br>思路：</p>
<ul>
<li>怎么得到要删除节点的前一个节点？<br>如果想要删除单链表中的一个节点，那我们必须得有这个节点的前驱。<br>如何一次遍历就得到一个节点的前驱？弄个<code>beforeNode</code>，每次<code>node = node-&gt;next</code>之前，都把<code>node</code>赋值给<code>beforeNode</code>，这样<code>beforeNode</code>就一直是<code>node</code>前一个节点的指针了。同时还要注意<code>beforeNode</code>要初始化成<code>(ListNode*)nullptr</code>，这样我们就可以根据它是不是<code>nullptr</code>来判断<code>node</code>是不是头节点了。</li>
<li>怎么一次遍历找到倒数第k个节点<br>先让<code>head</code>往前移动k个位置，之后再让<code>head</code>和<code>nthNode</code>一起往前移动，直到<code>head</code>移动到末尾(<code>nullptr</code>)。此时的<code>nthNode</code>就是倒数第k个节点了。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">auto</span> np = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// backup</span></span><br><span class="line">            <span class="keyword">auto</span> next = p-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> hnext = head-&gt;next;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            np-&gt;next = p;</span><br><span class="line">            <span class="comment">// forward</span></span><br><span class="line">            np = np-&gt;next;</span><br><span class="line">            p  = next;</span><br><span class="line">            head = hnext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = p-&gt;next;</span><br><span class="line">            p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            np-&gt;next = p;</span><br><span class="line">            np = np-&gt;next;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="反转整个链表"><a href="#反转整个链表" class="headerlink" title="反转整个链表"></a>反转整个链表</h2><p>剑指Offer 24, <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LC206 Reverse Linked List</a><br>特殊情况：</p>
<ul>
<li><code>head == nullptr</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;     </span><br><span class="line">        ListNode* pHead = <span class="literal">nullptr</span>;       </span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = pHead;</span><br><span class="line">            pHead = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="反转部分链表"><a href="#反转部分链表" class="headerlink" title="反转部分链表"></a>反转部分链表</h2><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LC92 Reverse Linked List II</a><br>思路：<br>如果我们逆序的链表的一部分，那么我们就得获得这个链表m前面那个节点和n后面那个节点的指针。这样逆序之后我们才好链接。<br>如果逆序的是第一个节点，即<code>m==0</code>，那就让m前面那个节点设置成nullptr即可。以后判断的时候可以用。</p>
<p>特殊情况：</p>
<ul>
<li><code>head == nullptr</code></li>
<li><code>m == 0</code></li>
<li><code>m == n</code></li>
</ul>
<p>特殊情况当中<code>m == 0</code>非常讨厌。为了必然这种情况发生，还是采用dummyHead的方式，简单好写。<br>另一个让人特别的迷糊的地方就是逆序后链表哪里是头，哪里是尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                                       reverse_last</span><br><span class="line">                                             ^</span><br><span class="line">                           reverse           |</span><br><span class="line">     +-+-+-+-+-+  +-+-----          +-+-+-+-+++  +-+-----</span><br><span class="line">     | | | | | |  | |      +------&gt; | | | | | |  | |</span><br><span class="line">     +++-+-+-+++  +++-----          +++-+-+-+-+  +++-----</span><br><span class="line">      ^       ^    ^                 ^            ^</span><br><span class="line">      |       |    |                 |            |</span><br><span class="line">      +       +    +                 +            +</span><br><span class="line">reverse_last ptr head               ptr         head</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆序之前将链表头保存在起来。</span></span><br><span class="line"><span class="comment">// 逆序之后reverse_last所指之处即为链表尾</span></span><br><span class="line"><span class="keyword">auto</span> reverse_last = head;</span><br><span class="line"><span class="comment">// 逆序之后,ptr所指之处即为逆序后的链表头</span></span><br><span class="line"><span class="comment">// 逆序之后,head 所指之处为原来链表中，在被逆序的序列之后的第一个节点。</span></span><br><span class="line">ListNode* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">cnt = n - m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">    head-&gt;next = ptr;</span><br><span class="line">    ptr = head;</span><br><span class="line">    head = next;</span><br><span class="line">    --cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">auto</span> p = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// backup</span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            <span class="keyword">auto</span> cur = head;</span><br><span class="line">            cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            p-&gt;next = cur;</span><br><span class="line">            <span class="comment">// move forward</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now p is at the end of the first part</span></span><br><span class="line">        <span class="comment">// head is at the beginning of the reverse part</span></span><br><span class="line">        <span class="keyword">auto</span> r_tail = head;</span><br><span class="line">        ListNode* r_head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> cnt = n - m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//backup</span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            <span class="keyword">auto</span> cur = head;</span><br><span class="line">            cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            cur-&gt;next = r_head;</span><br><span class="line">            <span class="comment">// move forward</span></span><br><span class="line">            r_head = cur;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// now head is at the beginning of part 3</span></span><br><span class="line">        <span class="comment">// splice r_tail with head</span></span><br><span class="line">        r_tail-&gt;next = head;</span><br><span class="line">        <span class="comment">// splice p with r_head</span></span><br><span class="line">        p-&gt;next = r_head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><p><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">LC234 Palindrome Linked List</a><br>题目要求用$O(n)$的时间复杂度和$O(1)$的空间复杂度来判断一个单向链表是否是回文的。<br>思路：</p>
<ul>
<li>先遍历一次链表，找到链表长度l。</li>
<li>如果l是奇数，我们就从l/2 + 1的位置开始给链表逆序（index 从 0开始）(因为121也是回文！)。如果l是偶数，就从l/2的位置开始给链表逆序。</li>
<li>逆序之后我们比较两个链表是否相同就可以了。</li>
<li>这会修改原始链表！</li>
</ul>
<p>下面的代码修改了原始链表，而且并没有帮忙改回去。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">        <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> lhead = head;</span><br><span class="line">        <span class="keyword">auto</span> rhead = head;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(len &amp; <span class="number">1</span>) len = len / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>        len = len / <span class="number">2</span>;        </span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            --len;</span><br><span class="line">            rhead = rhead-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">auto</span> rhead2 = rhead;</span><br><span class="line">        <span class="keyword">auto</span> tmp = (ListNode*)<span class="literal">nullptr</span>;        </span><br><span class="line">        <span class="keyword">while</span>(rhead2)&#123;</span><br><span class="line">            <span class="keyword">auto</span> next = rhead2-&gt;next;</span><br><span class="line">            rhead2-&gt;next = tmp;</span><br><span class="line">            tmp = rhead2;</span><br><span class="line">            rhead2 = next;</span><br><span class="line">        &#125;        </span><br><span class="line">        rhead = tmp;        </span><br><span class="line">        <span class="keyword">while</span>(lhead &amp;&amp; rhead)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lhead-&gt;val != rhead-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            lhead = lhead-&gt;next;</span><br><span class="line">            rhead = rhead-&gt;next;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="comment">//resume the linked list is not required in this problem.    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h1><p><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">LC61 Rotate List</a><br>高级版的链表的倒数第k个节点。先遍历链表找到链表的长度。然后用n = k mod len，之后从倒数的第n位开始给链表裁下来放在前面即可。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> end = head;</span><br><span class="line">        <span class="keyword">while</span>(end)&#123;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> num = k % len; </span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> head;        </span><br><span class="line">        <span class="keyword">auto</span> last = head;</span><br><span class="line">        <span class="keyword">auto</span> pre_rk = head;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            --num;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">while</span>(last-&gt;next)&#123;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">            pre_rk = pre_rk-&gt;next;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">auto</span> rk = pre_rk-&gt;next;</span><br><span class="line">        pre_rk-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        last-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> rk;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="链表的环"><a href="#链表的环" class="headerlink" title="链表的环"></a>链表的环</h1><h2 id="找出链表的环"><a href="#找出链表的环" class="headerlink" title="找出链表的环"></a>找出链表的环</h2><p>剑指Offer 23, <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LC141 Linked List Cycle</a>, <a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LC142 Linked List Cycle II
</a></p>
<p>目标：</p>
<ul>
<li>判断链表是否有环</li>
<li>确定环的长度</li>
<li>确定环的入口节点</li>
</ul>
<p>剑指Offer 23中给出了用快慢指针来判断是否有环的方法。但其确定环的长度和入口节点的方法太复杂。这里我们给出一种更简单的方法，用来确定入口节点和环长。</p>
<ul>
<li>使用两个指针，一个指针一次移动一步，另一个指针一次移动两步</li>
<li>不断向前移动两个指针，直到<ul>
<li>两个指针相遇</li>
<li>快指针移动到了<code>nullptr</code> $\rightarrow$ 证明链表无环。</li>
</ul>
</li>
<li>相遇的时候，慢指针移动的步数就是环长。不需要像《剑指Offer》里面一样再用两个指针来计数。</li>
<li>从【相遇的节点】和【链表头】各自出发一个指针，每次向前移动一个节点，直到两个指针相遇。这个指针就是链表的头入口。</li>
</ul>
<p>证明算法的正确性：</p>
<p>证明相交的时间刚好是<em>环的长度</em>:<br>假设链表存在环。设链表的环的入口节点是第$n$个节点，环中最后一个节点（也是环中环入口节点前一个节点）为$m$。必然有$m &gt; n$。设快节点速度为$2$，慢节点速度为$1$。快节点进入环的时间是$\frac{n}{2}$，快节点到环中最后一个节点的时间是$\frac{m}{2}$。之后在$[\frac{m}{2}, \frac{m}{2}+\frac{m-n}{2})$时间内，快节点的位置满足方程$P_f = n+2(t - \frac{m}{2}) = 2t+n-m$。慢节点的坐标满足方程$P_s = t$。假设在$[\frac{m}{2}, \frac{m}{2}+\frac{m-n}{2})]$能相交，求交点得相交时间为$\frac{m}{2}&lt; m-n &lt; \frac{m}{2}+\frac{m-n}{2}$，因此的确在此时间段内相交。相交的时间刚好是<em>环的长度</em>。</p>
<p>注意在实现这个算法的时候有一些小细节：</p>
<pre><code>- 建议用一个while(true)并其中用流程控制跳出，如果在while的括号里判断就会出现一些很诡异的BUG，原因未知。而且如果你想在while的括号里判断，就得让两个指针初始化成不一样的（`fast=head-&gt;next, slow = head`），在循环开始前又得判断一次fast是不是空指针，很麻烦。
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!fast) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!fast) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        slow = head;       </span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> slow;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!fast) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!fast) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head == slow) <span class="keyword">return</span> head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LC287 Find the Duplicate Number</a></p>
<blockquote>
<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
</blockquote>
<p>这个题可以被转化成链表求环问题。如果$n+1$个数字，每个数组的取值范围都是$[1, n]$，根据抽屉原理，必然有两个数字是相同的。我们把每一个数组的元素看作链表的一个<code>node</code>，而数组里存放的数组看作是<code>next</code>，我们就得到了一个有环的链表（有两个<code>next</code>是相同的）。我们用上面链表求环的方法就可以在$O(n)$的时间复杂度和$O(1)$的空间复杂度下完成这个问题了。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="两个链表的公共节点"><a href="#两个链表的公共节点" class="headerlink" title="两个链表的公共节点"></a>两个链表的公共节点</h1><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">LC160 Intersection of Two Linked Lists</a></p>
<p>如果两个链表一样长的话，直接让指针在链表头处一起向前移动，直到相等，就找到了公共节点了。可惜这个题两个链表不一定是一样长的。但我们可以通过遍历两个链表，得到长度差，让长链表指针先走。这样就变成了”一样长”的链表了。</p>
<p>思路</p>
<ul>
<li>首先我们得获得两个链表的长度<code>lenA</code>和<code>lenB</code></li>
<li>计算两个链表的长度差<code>adv = abs(lenA - lenB)</code></li>
<li>再分别从两个链表头处开始，让长链表的头指针先走<code>adv</code></li>
<li>再让两个指针一起往前走，直到【相等】 或者 一个出现【<code>nullptr</code>】。<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> pHeadA = headA;</span><br><span class="line">        <span class="keyword">auto</span> pHeadB = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">size_t</span> lenA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(headA &amp;&amp; headB)&#123;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">            ++lenA;</span><br><span class="line">            ++lenB;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(headA)&#123;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            ++lenA;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(headB)&#123;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">            ++lenB;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> _getIntersection = [](ListNode* pHeadA, ListNode* pHeadB, <span class="keyword">size_t</span> adv)&#123; </span><br><span class="line">            <span class="keyword">while</span>(adv)&#123;</span><br><span class="line">                pHeadA = pHeadA-&gt;next;</span><br><span class="line">                --adv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(pHeadA &amp;&amp; pHeadB)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pHeadA == pHeadB) <span class="keyword">return</span> pHeadA;</span><br><span class="line">                pHeadA = pHeadA-&gt;next;</span><br><span class="line">                pHeadB = pHeadB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (ListNode*)<span class="literal">nullptr</span>; </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB) <span class="keyword">return</span> _getIntersection(pHeadA, pHeadB, lenA - lenB);</span><br><span class="line">        <span class="keyword">else</span>            <span class="keyword">return</span> _getIntersection(pHeadB, pHeadA, lenB - lenA); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
</li>
</ul>
<h1 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h1><h2 id="合并2个排序的链表"><a href="#合并2个排序的链表" class="headerlink" title="合并2个排序的链表"></a>合并2个排序的链表</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LC21 Merge Two Sorted Lists</a><br>该题目为归并(merge)的实现。见”排序”。</p>
<p>注意：</p>
<ul>
<li>链表的归并过程不需要置裁剪下来的节点next指针为nullptr，因为这里不涉及到链表倒置。</li>
<li>当一个链表到头之后，不需要再用while循环来拼接另一个链表。只需要接上即可。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code更清新的版本
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> DummyHead = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ptr = &amp;DummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        slice-splice 版本
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slice_append</span><span class="params">(ListNode** pl2, ListNode** pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; l2 = *pl2;</span><br><span class="line">    <span class="keyword">auto</span>&amp; p = *pp;</span><br><span class="line">    <span class="comment">//backup </span></span><br><span class="line">    <span class="keyword">auto</span> next = l2-&gt;next;</span><br><span class="line">    <span class="comment">//slice</span></span><br><span class="line">    l2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//splice</span></span><br><span class="line">    p-&gt;next = l2;</span><br><span class="line">    <span class="comment">//forward</span></span><br><span class="line">    l2 = next;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">auto</span> p = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l2-&gt;val &lt; l1-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                slice_append(&amp;l2, &amp;p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                slice_append(&amp;l1, &amp;p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="合并k个排序的链表"><a href="#合并k个排序的链表" class="headerlink" title="合并k个排序的链表"></a>合并k个排序的链表</h2><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LC23 Merge k Sorted Lists</a><br>该题目为k路归并(merge sort)的实现。见”排序”。</p>
<p>注意的问题：</p>
<ul>
<li>测试用例很恶心，有空的链表头指针。如果不事先把这些东西remove-erase掉，就会导致在比较器里解引用空指针。当然另一个解决办法是在比较器中判断是不是空指针。由于比较器是要被调用最频繁的函数，在其中引入流程控制就会大大降低效率。不如直接线性搜索去掉空指针。</li>
<li>同时也是空指针的问题，注意push()进入队列的也不能是空指针，否则也会引起上面的问题。但是在这里引入一个判断，对整体的效率影响不大。</li>
<li><code>priority_queue</code>的构造函数除非是传<code>iterator</code>来构造的版本，第一个参数都是自定义比较器。而且应该将<code>lists</code>移动到<code>pq</code>中构造，避免复制。</li>
<li>一定要先记录top()然后尽早pop()，如果push()了新节点之后再pop()，可能会把刚push()进来的节点pop()出去，导致BUG。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        lists.erase(remove(lists.begin(), lists.end(), <span class="literal">nullptr</span>), lists.end());</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">auto</span> p = &amp;dummy;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span> lhs, <span class="keyword">auto</span> rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs-&gt;val &gt; rhs-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> pq = priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt;&#123;cmp, <span class="built_in">std</span>::move(lists)&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            <span class="keyword">auto</span> next = node-&gt;next;</span><br><span class="line">            node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">            <span class="comment">// forward</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(next)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="链表插入排序"><a href="#链表插入排序" class="headerlink" title="链表插入排序"></a>链表插入排序</h2><p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">LC147 对链表进行插入排序</a></p>
<p>仍然按照裁剪、变换、拼接的方式进行，需要注意的是这次拼接的位置不再是新链表的尾部。而是要对新链表进行线性查找，找到第一个比当前node大的node(greater)，和greater前面一个node(before)。一些边界条件：</p>
<pre><code>- greater可能是`nullptr`：这个无所谓，因为只会把greater拼在node后面
- before是`nullptr`：也就是说第一个比当前node大的node是新链表头，我们只需将这个node的next设置为当前链表头，并返回新链表头即可。
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ListNode* pos, ListNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> next = pos-&gt;next;</span><br><span class="line">    pos-&gt;next = node;</span><br><span class="line">    node-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> p = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// backup</span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            <span class="keyword">auto</span> p1 = p;</span><br><span class="line">            <span class="keyword">auto</span> p2 = dummy.next;</span><br><span class="line">            <span class="keyword">while</span>(p2 &amp;&amp; head-&gt;val &gt; p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            insert(p1, head);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//forward</span></span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ptr = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            ptr = insert(ptr, head);</span><br><span class="line">            <span class="comment">// move on</span></span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head, ListNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// we have to find the first node</span></span><br><span class="line">        <span class="comment">// (and the node before that node) </span></span><br><span class="line">        <span class="comment">// that is greater than the given node</span></span><br><span class="line"></span><br><span class="line">        ListNode* before = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> greater = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(greater &amp;&amp; !(node-&gt;val &lt; greater-&gt;val))</span><br><span class="line">        &#123;</span><br><span class="line">            before = greater;</span><br><span class="line">            greater = greater-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(before) before-&gt;next = node;</span><br><span class="line">        node-&gt;next = greater;     </span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the new head</span></span><br><span class="line">        <span class="keyword">if</span>(!before) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="链表归并排序"><a href="#链表归并排序" class="headerlink" title="链表归并排序"></a>链表归并排序</h2><p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LC148 排序链表</a></p>
<p>采用自低向上的归并排序，时间复杂度O(NlogN)，不需要额外空间。</p>
<p>思路：</p>
<ul>
<li>写一个merge方法，可以merge任意长度的两个链表，即<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LC21 Merge Two Sorted Lists</a>。</li>
<li>写一个<code>cut(ListNode* head, size_t len)</code>方法，将从head开始的，长度为len的链表从原链表上裁剪下来。返回被裁剪后的原链表头指针。如果len大于原链表的长度，返回<code>nullptr</code>。这里注意一定别忘了把被裁下那一段的尾节点的<code>next</code>指针置空。</li>
<li>遍历链表，找出链表的长度<code>len</code></li>
<li>维护一个裁剪长度变量，初始化为<code>cutLen = 1</code><ul>
<li>初始化一个<code>dummyHead</code>，用来连接从原链表上被裁下来的链表。这里为了方便，要把这个哑节点的<code>next</code>设置为<code>head</code>。</li>
<li>初始化<code>cur</code>指针为链表头指针</li>
<li>从<code>left = cur</code>处，裁剪一个长度为<code>cutLen</code>的链表，得到剩余链表的头指针<code>right</code></li>
<li>从<code>right</code>处，再裁减一个长度为<code>cutLen</code>的链表，将返回的剩余链表的头指针赋值给<code>cur</code></li>
<li>归并<code>left</code>和<code>right</code>两个链表，将返回的链表头的指针赋值给<code>dummyHead-&gt;next</code></li>
<li>更新<code>dummyHead</code>为其后面所连接的链表的尾节点指针</li>
<li>重复上述步骤直到<code>cur</code>为空指针</li>
</ul>
</li>
<li>更新<code>cutLen = cutLen * 2</code></li>
<li>重复上述步骤直到<code>cutLen &gt;= len</code></li>
</ul>
<p>Jul/14/2020 可以省略第一次对链表的遍历。当从链表上<code>cut</code>下来的第一段就导致<code>cur</code>指针变为<code>nullptr</code>时，就自然有<code>cutLen &gt;= len</code>了。</p>
<p>Feb/18/2020 重新写了一次sortList，但是debug了好久好久</p>
<ul>
<li>链表的TLE不一定是因为你程序中有死循环，还可能是因为你的链表出环了</li>
<li>错误点1: mergeList里面的主循环忘记更新指针<code>end = end-&gt;next</code></li>
<li>错误点2: sortList里面的外层循环，忘记了重置指针<code>end = &amp;dummy</code><ul>
<li>能让他称为局部变量的就尽量写成局部变量，这样就不会忘记更新了</li>
</ul>
</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Jul/14/2020 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">slice_front</span><span class="params">(ListNode* head, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i&#123;<span class="number">1</span>&#125;; i &lt; n &amp;&amp; head; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">slice_append</span><span class="params">(ListNode*&amp; l2, ListNode*&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// backup</span></span><br><span class="line">    <span class="keyword">auto</span> next = l2-&gt;next;</span><br><span class="line">    <span class="comment">// slice</span></span><br><span class="line">    l2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// splice</span></span><br><span class="line">    p-&gt;next = l2;</span><br><span class="line">    <span class="comment">// forward</span></span><br><span class="line">    l2 = next;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">merge_list</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = &amp;dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l2-&gt;val &lt; l1-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            slice_append(l2, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            slice_append(l1, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        slice_append(l1, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        slice_append(l2, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> make_pair(dummy.next, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> len&#123;<span class="number">1</span>&#125;;; len *= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = dummy.next;</span><br><span class="line">            <span class="keyword">auto</span> p = &amp;dummy;</span><br><span class="line">            <span class="keyword">while</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// slice the first part</span></span><br><span class="line">                <span class="keyword">auto</span> first_head = cur;</span><br><span class="line">                cur = slice_front(cur, len);</span><br><span class="line">                <span class="comment">// if the first_head is dummy.next and cur is nullptr,</span></span><br><span class="line">                <span class="comment">// then we do not need to continue</span></span><br><span class="line">                <span class="keyword">if</span>(first_head == dummy.next &amp;&amp; !cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> first_head;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// slice the second part</span></span><br><span class="line">                <span class="keyword">auto</span> second_head = cur;</span><br><span class="line">                cur = slice_front(cur, len);</span><br><span class="line">                <span class="comment">// merge them together</span></span><br><span class="line">                <span class="keyword">auto</span> [merge_head, merge_tail] </span><br><span class="line">                    = merge_list(first_head, second_head);</span><br><span class="line">                <span class="comment">// append them to the dummy head.</span></span><br><span class="line">                p-&gt;next = merge_head;</span><br><span class="line">                p = merge_tail;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Feb/18/2020 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// count the size of the list</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> cntPtr = head;</span><br><span class="line">        <span class="keyword">while</span>(cntPtr)</span><br><span class="line">        &#123;</span><br><span class="line">            ++size;</span><br><span class="line">            cntPtr = cntPtr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">2</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// set up dummyHead</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> end   = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bottom-up mergesort</span></span><br><span class="line">        <span class="keyword">int</span> cut_size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cut_size &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(head)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cut the first piece</span></span><br><span class="line">                <span class="keyword">auto</span> first_head = head;</span><br><span class="line">                head = cutList(head, cut_size);</span><br><span class="line">                <span class="comment">// cut the second piece</span></span><br><span class="line">                <span class="keyword">auto</span> second_head = head;</span><br><span class="line">                head = cutList(head, cut_size);</span><br><span class="line">                <span class="comment">// merge them together</span></span><br><span class="line">                <span class="keyword">auto</span> [merge_head, merge_end] = mergeList(first_head, second_head);</span><br><span class="line">                <span class="comment">// append the list</span></span><br><span class="line">                end-&gt;next = merge_head;</span><br><span class="line">                end = merge_end;</span><br><span class="line">            &#125;</span><br><span class="line">            head = dummy.next;</span><br><span class="line">            end = &amp;dummy;</span><br><span class="line">            cut_size *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cut a sublist of size n in out of the beginning of </span></span><br><span class="line">    <span class="comment">// head, return the head of the remaining part.</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">cutList</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        --n;</span><br><span class="line">        ListNode* ptr = head;</span><br><span class="line">        <span class="keyword">while</span>(ptr &amp;&amp; n)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// not enough node to cut</span></span><br><span class="line">        <span class="keyword">if</span>(!ptr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// cut </span></span><br><span class="line">        <span class="keyword">auto</span> next = ptr-&gt;next;</span><br><span class="line">        ptr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; mergeList(ListNode* h1, ListNode* h2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> end   = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(h1 &amp;&amp; h2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h2-&gt;val &lt; h1-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                end-&gt;next = h2;</span><br><span class="line">                h2 = h2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                end-&gt;next = h1;</span><br><span class="line">                h1 = h1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(h1)</span><br><span class="line">        &#123;</span><br><span class="line">            end-&gt;next = h1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(h2)</span><br><span class="line">        &#123;</span><br><span class="line">            end-&gt;next = h2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(end-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        end-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;dummy.next, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Feb/9/2020 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> ptr = head;</span><br><span class="line">        <span class="keyword">auto</span> dummyNode = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="comment">//we need to know the length of the list</span></span><br><span class="line">        <span class="keyword">while</span>(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cutLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cutLen &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = dummyNode.next;</span><br><span class="line">            <span class="keyword">auto</span> pDummyNode = &amp;dummyNode;</span><br><span class="line">            <span class="keyword">while</span>(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> left  = ptr;</span><br><span class="line">                <span class="keyword">auto</span> right = cut(left, cutLen);</span><br><span class="line">                ptr = cut(right, cutLen);</span><br><span class="line"></span><br><span class="line">                pDummyNode-&gt;next = mergeList(left, right);</span><br><span class="line">                <span class="keyword">while</span>(pDummyNode-&gt;next)</span><br><span class="line">                &#123;</span><br><span class="line">                    pDummyNode = pDummyNode-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                                </span><br><span class="line">            &#125;</span><br><span class="line">            cutLen *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        --len;</span><br><span class="line">        <span class="comment">// move to the end of the linked list </span></span><br><span class="line">        <span class="comment">// that has length == len</span></span><br><span class="line">        <span class="keyword">while</span>(len &amp;&amp; head)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            --len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// not enough nodes, return nullptr.</span></span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> newHead = head-&gt;next;</span><br><span class="line">        <span class="comment">// DO NOT FORGET TO CUT!</span></span><br><span class="line">        <span class="comment">// cut the connection between this linked list and the reminder</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode dummyNode = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ptr = &amp;dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">LC138 Copy List with Random Pointer</a>， 剑指Offer 35</p>
<h2 id="使用hashmap的解法"><a href="#使用hashmap的解法" class="headerlink" title="使用hashmap的解法"></a>使用hashmap的解法</h2><ul>
<li>遍历链表，将链表中的node复制一份并记录下新的地址。以node原来的地址为Key, 新的地址为value存在hashmap当中。注意：<code>nullptr</code>的不用存，因为也不用对应。<br>这次遍历的过程中，还要注意保存一下每次新建的node的地址到下一个循环。重置这个地址的node的next指针到下一个新建的node。</li>
<li>再遍历新的链表，设置random指针的值。方法就是用原来的random当Key从hashmap当中找新的random即可。</li>
</ul>
<p>使用dummyNode，减少循环内的流程控制语句，可以显著提升效率。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; <span class="built_in">map</span>&#123;&#125;;</span><br><span class="line">        Node copyHead = Node&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> pCopyHead = &amp;copyHead;</span><br><span class="line">        <span class="comment">// build the new linked list</span></span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            pCopyHead-&gt;next = <span class="keyword">new</span> Node&#123;head-&gt;val&#125;;</span><br><span class="line">            pCopyHead-&gt;next-&gt;random = head-&gt;random;</span><br><span class="line">            <span class="comment">// set up the mapping</span></span><br><span class="line">            <span class="built_in">map</span>[head] = pCopyHead-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            pCopyHead = pCopyHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterate throught the new linked list</span></span><br><span class="line">        <span class="comment">// fix the random pointer</span></span><br><span class="line">        pCopyHead = &amp;copyHead;</span><br><span class="line">        pCopyHead = pCopyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(pCopyHead)</span><br><span class="line">        &#123;</span><br><span class="line">            pCopyHead-&gt;random = <span class="built_in">map</span>[pCopyHead-&gt;random];</span><br><span class="line">            pCopyHead = pCopyHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> copyHead.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        旧LeetCode的Node API
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; nodeMap;</span><br><span class="line">        <span class="keyword">auto</span> copiedHead = head;</span><br><span class="line">        <span class="keyword">auto</span> nodeCopied = <span class="keyword">new</span> Node(INT_MIN, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">auto</span> nodeCopied2 = nodeCopied;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            nodeCopied-&gt;next = <span class="keyword">new</span> Node(head-&gt;val, <span class="literal">nullptr</span>, head-&gt;random);</span><br><span class="line">            nodeCopied = nodeCopied-&gt;next;</span><br><span class="line">            nodeMap[head] = nodeCopied; </span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pair : nodeMap)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pair.second-&gt;random)</span><br><span class="line">                pair.second-&gt;random = nodeMap[pair.second-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> nodeCopied2;</span><br><span class="line">        <span class="keyword">return</span> nodeMap[copiedHead];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个没用使用hashmap，而是采用排序数组上二分查找的实现，仅仅是为了练习而写（不推荐）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pNodePair = <span class="built_in">std</span>::pair&lt;Node*, Node*&gt;;</span><br><span class="line">        Node* tmpHead = head;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pNodePair&gt; vpNodePair;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            vpNodePair.emplace_back(head,<span class="keyword">new</span> Node(head-&gt;val,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>));</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::sort(vpNodePair.begin(),vpNodePair.end(),[](<span class="keyword">const</span> pNodePair&amp; lhs, <span class="keyword">const</span> pNodePair&amp; rhs )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::less&lt;Node*&gt;()(lhs.first,rhs.first);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> compare = [](<span class="keyword">const</span> pNodePair&amp; lhs, Node* rhs)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::less&lt;Node*&gt;()(lhs.first,rhs);</span><br><span class="line">            &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> findCorrespondingNode = [&amp;vpNodePair,&amp;compare](Node* what)&#123;</span><br><span class="line">            <span class="keyword">return</span> what == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : <span class="built_in">std</span>::lower_bound(vpNodePair.begin(),vpNodePair.end(),what,compare)-&gt;second;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::for_each(vpNodePair.begin(),vpNodePair.end(),[&amp;vpNodePair,&amp;findCorrespondingNode](<span class="keyword">const</span> pNodePair&amp; pair)&#123;</span><br><span class="line">            pair.second-&gt;next = findCorrespondingNode(pair.first-&gt;next);</span><br><span class="line">            pair.second-&gt;random = findCorrespondingNode(pair.first-&gt;random);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> findCorrespondingNode(tmpHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="空间复杂度为O-1-的解法"><a href="#空间复杂度为O-1-的解法" class="headerlink" title="空间复杂度为O(1)的解法"></a>空间复杂度为O(1)的解法</h2><p>解法来自《剑指Offer》面试题35</p>
<p>思路：<br>把每一个复制后的node先放在原来的node之后。这样找random的时候，直接找random-&gt;next即可。</p>
<ul>
<li>先遍历一次链表，在每一个node之后都加入一份该node的拷贝。</li>
<li>再遍历一次链表，把拷贝的node的random修改为random-&gt;next。</li>
<li>再遍历一次链表，把两个链表分离开。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> ddHead = head;</span><br><span class="line">        <span class="keyword">auto</span> copyHead = head;</span><br><span class="line">        <span class="keyword">auto</span> newHead = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">auto</span> nextNode = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> Node(head-&gt;val, nextNode, head-&gt;random);</span><br><span class="line">            head = nextNode;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">while</span>(newHead)&#123;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(newHead-&gt;random)</span><br><span class="line">                newHead-&gt;random = newHead-&gt;random-&gt;next;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> finalHead = copyHead-&gt;next;     </span><br><span class="line">        <span class="keyword">while</span>(copyHead)&#123;</span><br><span class="line">            <span class="keyword">auto</span> nodeCopied = copyHead-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(nodeCopied)</span><br><span class="line">                copyHead-&gt;next = nodeCopied -&gt;next;</span><br><span class="line">            copyHead = nodeCopied;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalHead;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">LC83 删除排序链表中的重复元素</a>, <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">LC82 删除排序链表中的重复元素II</a></p>
<p>LC83的思路也是操作链表的一般思路，即取下、处理、拼接。需要注意的细节：</p>
<pre><code>- 处理之前别忘备份一份`next`
- 处理之后一定要把`next`置空
- 拼接之后要移动到末尾
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> np = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// backup</span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val != np-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                np-&gt;next = head;</span><br><span class="line">                np = np-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<p>LC82的思路：因为要求删掉有重复的Node，所以不能简单的像前一题一样，判断和新链表末尾的元素是否相同。</p>
<ul>
<li>维护两个指针<code>l</code>和<code>r</code>，不变式为<code>r &gt;= l</code>且<code>l</code>总为链表头</li>
<li>初始化<code>l</code> 和 <code>r</code> 为<code>head</code>和<code>head-&gt;next</code></li>
<li>检查<code>l</code>和<code>r</code><ul>
<li>如果<code>l</code>不是空指针，但<code>r</code>是空指针。这说明<code>l</code>所指的node已经是链表中最后一个node了。我们直接把<code>l</code>裁减拼接即可。</li>
<li>如果不相等，就把<code>l</code>对应的node裁减，拼接到新链表尾。</li>
<li>如果相等，就向右移动<code>r</code>直到<code>l</code>和<code>r</code>不相等<ul>
<li>注意如果<code>r == nullptr</code>(被移动到了链表尾部)，为了维持不变式，需要设置<code>l == nullptr</code></li>
</ul>
</li>
</ul>
</li>
<li>向前移动<code>l</code>和<code>r</code></li>
</ul>
<p>Feb/18/2020更新：</p>
<ul>
<li>我们总是保证r在l前面，这一点体现将l从链表中拿下接到新链表之后。l和r都要向前一步。</li>
<li>如果在检查l和r相等的分支中，r移动到了链表末尾，我们可以直接break循环，因为此时l到r之间全为重复节点。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> p = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = head;</span><br><span class="line">            <span class="keyword">auto</span> r = head-&gt;next;</span><br><span class="line">            <span class="comment">// dupicate</span></span><br><span class="line">            <span class="keyword">while</span>(r &amp;&amp; l-&gt;val == r-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// duplicate if r was moved.</span></span><br><span class="line">            <span class="keyword">if</span>(r != l-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                head = r;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// backup </span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            <span class="keyword">auto</span> cur = head;</span><br><span class="line">            cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            p-&gt;next = cur;</span><br><span class="line">            <span class="comment">// forward</span></span><br><span class="line">            head = next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Feb/18/2020-code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> end   = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> l = head;</span><br><span class="line">        <span class="keyword">auto</span> r = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// check if l and r are the same</span></span><br><span class="line">            <span class="comment">// if so, we have to move r unitl they </span></span><br><span class="line">            <span class="comment">// are not same</span></span><br><span class="line">            <span class="keyword">if</span>(r &amp;&amp; l-&gt;val == r-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(r &amp;&amp; l-&gt;val == r-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = r-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// if r moves to the end, then all duplicates</span></span><br><span class="line">                <span class="comment">// between l and r, we could break the loop</span></span><br><span class="line">                <span class="keyword">if</span>(!r) <span class="keyword">break</span>; </span><br><span class="line">                <span class="comment">// move l to r</span></span><br><span class="line">                l = r;</span><br><span class="line">                <span class="comment">// move r to r-&gt;next;</span></span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">                <span class="comment">// back to top and check again</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// l-&gt;val != r-&gt;val, we could append l onto the list</span></span><br><span class="line">            <span class="comment">// cut</span></span><br><span class="line">            <span class="keyword">auto</span> next = l-&gt;next;</span><br><span class="line">            l-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// append</span></span><br><span class="line">            end-&gt;next = l;</span><br><span class="line">            <span class="comment">// forward</span></span><br><span class="line">            l = next;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(r) r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Feb/9/2020 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ptr = &amp;dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> l = head;</span><br><span class="line">        <span class="keyword">auto</span> r = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invariance r &gt;= l</span></span><br><span class="line">        <span class="comment">// invariance l is the head, no node points to l</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// the last node</span></span><br><span class="line">            <span class="keyword">if</span> (!r)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = l;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l-&gt;val != r-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// remove l form the list</span></span><br><span class="line">                l-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// splice l with the new list</span></span><br><span class="line">                ptr-&gt;next = l;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//increase l &amp; r</span></span><br><span class="line">                l = r;</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">                <span class="comment">//increase ptr</span></span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// found duplicate nodes</span></span><br><span class="line">            <span class="keyword">if</span> (l-&gt;val == r-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// continue move r unitl not duplicate</span></span><br><span class="line">                <span class="comment">// r may be moved to the end, r == nullptr</span></span><br><span class="line">                <span class="keyword">while</span>(r &amp;&amp; l-&gt;val == r-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = r-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// skip this part</span></span><br><span class="line">                l = r == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : r;</span><br><span class="line">                r = r == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">LC725 分隔链表</a></p>
<p>一个链表长为N，分隔成k个连续的部分，要求相差不超过一。可以用下面的方法算出每段的长度（不知道原因）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = len; k &gt; <span class="number">0</span>;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> cut = i / k; <span class="comment">// &lt;----- cut 即为每段的长度。</span></span><br><span class="line">    i -= cut;</span><br><span class="line">    --k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>比如长为10的链表分成3分：</p>
<ul>
<li>10 / 3 = 3, 10 - 3 = 7</li>
<li>7  / 2 = 3,  7 - 3 = 4</li>
<li>4  / 1 = 4,  4 - 4 = 0</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">splice_front</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; splitListToParts(ListNode* root, <span class="keyword">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> len = [root]()<span class="keyword">mutable</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> cut_lens = [=]()<span class="keyword">mutable</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i = len; k &gt; <span class="number">0</span>;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> cut = i / k;</span><br><span class="line">                res.push_back(cut);</span><br><span class="line">                i -= cut;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(res.begin(), res.end());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;ListNode*&gt;(cut_lens.size());</span><br><span class="line">        transform(cut_lens.begin(), cut_lens.end(), res.begin(), </span><br><span class="line">        [&amp;](<span class="keyword">int</span> cut_len) <span class="keyword">mutable</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cut_head = root;</span><br><span class="line">            root = splice_front(root, cut_len);</span><br><span class="line">            <span class="keyword">return</span> cut_head;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; splitListToParts(ListNode* head, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = lenList(head);</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; res&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> cut_seq = generateCutSeq(len, k);</span><br><span class="line">        <span class="keyword">auto</span> it = cut_seq.begin();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(it != cut_seq.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cut = *it;</span><br><span class="line">            <span class="keyword">auto</span> cut_head = head;</span><br><span class="line">            res.push_back(cut_head);</span><br><span class="line">            head = cutList(head, cut);</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generateCutSeq(<span class="keyword">int</span> len, <span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cut = len / k;</span><br><span class="line">            <span class="keyword">if</span>(cut == <span class="number">0</span>) cut = <span class="number">1</span>;</span><br><span class="line">            res.push_back(cut);</span><br><span class="line">            len -= cut;</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">while</span>(k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(<span class="number">0</span>);</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">cutList</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        --n;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; n)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// cut</span></span><br><span class="line">        <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="两个一组翻转链表"><a href="#两个一组翻转链表" class="headerlink" title="两个一组翻转链表"></a>两个一组翻转链表</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">LC24 两两交换链表中的节点</a></p>
<p>这个题的思路类似链表排序，每次cut下来一块链表，翻转好之后拼到dummyNode上，<strong>然后把dummyNode移动到末尾</strong>。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummyNode = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> pDummyNode = &amp;dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                next = head-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pDummyNode-&gt;next = cutAndSwap(head);</span><br><span class="line">            <span class="comment">// 一定是移动到末尾，不要思维定势</span></span><br><span class="line">            <span class="comment">// 只有一句pDummyNode = pDummyNode-&gt;next;是不够的</span></span><br><span class="line">            <span class="keyword">while</span>(pDummyNode-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                pDummyNode = pDummyNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">cutAndSwap</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> first  = head;</span><br><span class="line">        <span class="keyword">auto</span> second = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!second) &#123;</span><br><span class="line">            first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        second-&gt;next = first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LC24 K个一组翻转链表</a></p>
<p>按照裁剪，变换，拼接的思路来做，这个题根本不配hard</p>
<ul>
<li>裁剪：从当前指针开始，往后移动k-1位，就是要裁下来的部分。</li>
<li>变换：翻转链表</li>
<li>拼接上即可</li>
</ul>
<p>注意的细节：</p>
<ul>
<li>在翻转链表之后可以把尾节点和头节点一并传回，这样就不用遍历一次把新链表的尾节点移动到位了。</li>
<li>在变换之前一定别忘了备份next指针</li>
<li>在结束完拼接之后，别忘了更新<strong>新链表的尾节点</strong>和<strong>旧链表的头节点</strong></li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ptr = &amp;dummy;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span> || !head) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            <span class="keyword">auto</span> back = head;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; back; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                back = back-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(back)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> next = back-&gt;next;</span><br><span class="line">                back-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">// transform</span></span><br><span class="line">                <span class="keyword">auto</span> [newHead, newBack] = rotateList(head);</span><br><span class="line">                <span class="comment">//splice</span></span><br><span class="line">                ptr-&gt;next = newHead;</span><br><span class="line">                ptr = newBack;</span><br><span class="line">                head = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// back is nullptr, the last part of the list</span></span><br><span class="line">            <span class="comment">// just do splice will be OK</span></span><br><span class="line">            ptr-&gt;next = head;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; rotateList(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> back = head;</span><br><span class="line">        ListNode* newHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;newHead, back&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="将链表中偶数节点放在奇数节点后面"><a href="#将链表中偶数节点放在奇数节点后面" class="headerlink" title="将链表中偶数节点放在奇数节点后面"></a>将链表中偶数节点放在奇数节点后面</h2><p><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">LC328 Odd Even Linked List </a></p>
<p>使用两个dummyNode，一个供奇数节点用，另一个供偶数节点用。将从原来链表取下的节点分别放到两个dummyNode后面。之后再将偶数的链表头链接在奇数的链表末尾。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy_even = ListNode&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">auto</span> dummy_odd  = ListNode&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">auto</span> p_even = &amp;dummy_even;</span><br><span class="line">        <span class="keyword">auto</span> p_odd  = &amp;dummy_odd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> odd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// backup</span></span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            <span class="comment">// slice</span></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// splice</span></span><br><span class="line">            <span class="keyword">if</span>(odd)</span><br><span class="line">            &#123;</span><br><span class="line">                p_odd-&gt;next = head;</span><br><span class="line">                p_odd = p_odd-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p_even-&gt;next = head;</span><br><span class="line">                p_even = p_even-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            odd = !odd;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p_odd-&gt;next = dummy_even.next;</span><br><span class="line">        <span class="keyword">return</span> dummy_odd.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h2><p><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">LC143 重排链表</a></p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> ptr = head;</span><br><span class="line">        <span class="keyword">while</span>(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len = (len &amp; <span class="number">1</span>) ? len / <span class="number">2</span> + <span class="number">1</span> : len / <span class="number">2</span>;</span><br><span class="line">        ptr = head;</span><br><span class="line">        ListNode* beforePtr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            beforePtr = ptr;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slice</span></span><br><span class="line">        beforePtr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// transform</span></span><br><span class="line">        <span class="keyword">auto</span> newHead = rotateList(ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dummy = ListNode&#123;INT_MIN&#125;;</span><br><span class="line">        ptr = &amp;dummy;</span><br><span class="line">        <span class="comment">// splice</span></span><br><span class="line">        <span class="keyword">while</span>(newHead &amp;&amp; head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> headNext = head-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> newHeadNext = newHead-&gt;next;</span><br><span class="line"></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            newHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            </span><br><span class="line">            ptr-&gt;next = head;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next = newHead;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line"></span><br><span class="line">            head = headNext;</span><br><span class="line">            newHead = newHeadNext;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;next = head;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(newHead)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;next = newHead;</span><br><span class="line">            newHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* newHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h2 id="扁平化多级双向链表"><a href="#扁平化多级双向链表" class="headerlink" title="扁平化多级双向链表"></a>扁平化多级双向链表</h2><p><a href="https://xyfu.me/posts/2362a8ea/#%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">LC430 扁平化多级双向链表</a></p>
<p>使用两个辅助函数<code>insert</code>和<code>get_back</code>，将有<code>child</code>不为空的节点的<code>child</code>插入到当前链表中，之后清除<code>child</code>指针即可。<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* pos, Node* front, Node* back)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> next = pos-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// link pos with front</span></span><br><span class="line">    pos-&gt;next = front;</span><br><span class="line">    front-&gt;prev = pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// link back with next</span></span><br><span class="line">    back-&gt;next = next;</span><br><span class="line">    <span class="keyword">if</span>(next)</span><br><span class="line">    &#123;</span><br><span class="line">        next-&gt;prev = back;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_back</span><span class="params">(Node* front)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(front-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ohead = head;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;child)</span><br><span class="line">            &#123;</span><br><span class="line">                insert(head, head-&gt;child, get_back(head-&gt;child));</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ohead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag"># 链表</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/e8eb0481/" rel="prev" title="二分查找">
      <i class="fa fa-chevron-left"></i> 二分查找
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/e85d694a/" rel="next" title="二叉树">
      二叉树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#STL中的链表"><span class="nav-number">1.</span> <span class="nav-text">STL中的链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#删除节点问题"><span class="nav-number">2.</span> <span class="nav-text">删除节点问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#O-1-时间删除链表的一个给定节点"><span class="nav-number">2.1.</span> <span class="nav-text">O(1)时间删除链表的一个给定节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除链表中所有有给定值的节点"><span class="nav-number">2.2.</span> <span class="nav-text">删除链表中所有有给定值的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除链表中倒数第k个节点"><span class="nav-number">2.3.</span> <span class="nav-text">删除链表中倒数第k个节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#反转链表"><span class="nav-number">3.</span> <span class="nav-text">反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反转整个链表"><span class="nav-number">3.1.</span> <span class="nav-text">反转整个链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反转部分链表"><span class="nav-number">3.2.</span> <span class="nav-text">反转部分链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回文链表"><span class="nav-number">3.3.</span> <span class="nav-text">回文链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#旋转链表"><span class="nav-number">4.</span> <span class="nav-text">旋转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表的环"><span class="nav-number">5.</span> <span class="nav-text">链表的环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#找出链表的环"><span class="nav-number">5.1.</span> <span class="nav-text">找出链表的环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中重复的数字"><span class="nav-number">5.2.</span> <span class="nav-text">数组中重复的数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#两个链表的公共节点"><span class="nav-number">6.</span> <span class="nav-text">两个链表的公共节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表排序"><span class="nav-number">7.</span> <span class="nav-text">链表排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#合并2个排序的链表"><span class="nav-number">7.1.</span> <span class="nav-text">合并2个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并k个排序的链表"><span class="nav-number">7.2.</span> <span class="nav-text">合并k个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表插入排序"><span class="nav-number">7.3.</span> <span class="nav-text">链表插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表归并排序"><span class="nav-number">7.4.</span> <span class="nav-text">链表归并排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复杂链表的复制"><span class="nav-number">8.</span> <span class="nav-text">复杂链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用hashmap的解法"><span class="nav-number">8.1.</span> <span class="nav-text">使用hashmap的解法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间复杂度为O-1-的解法"><span class="nav-number">8.2.</span> <span class="nav-text">空间复杂度为O(1)的解法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#删除排序链表中的重复元素"><span class="nav-number">9.</span> <span class="nav-text">删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-number">10.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分隔链表"><span class="nav-number">10.1.</span> <span class="nav-text">分隔链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两个一组翻转链表"><span class="nav-number">10.2.</span> <span class="nav-text">两个一组翻转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#K个一组翻转链表"><span class="nav-number">10.3.</span> <span class="nav-text">K个一组翻转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将链表中偶数节点放在奇数节点后面"><span class="nav-number">10.4.</span> <span class="nav-text">将链表中偶数节点放在奇数节点后面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重排链表"><span class="nav-number">10.5.</span> <span class="nav-text">重排链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扁平化多级双向链表"><span class="nav-number">10.6.</span> <span class="nav-text">扁平化多级双向链表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xuanyi Fu</p>
  <div class="site-description" itemprop="description">Xuanyi Fu的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xuanyi-fu" title="GitHub → https://github.com/xuanyi-fu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5300073738" title="Weibo → https://weibo.com/5300073738" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xuanyi Fu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">130k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:58</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
