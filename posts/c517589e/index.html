<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xyfu.me').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="并查集主要用来解决动态连通性问题。连通性问题：LC200 Number of IslandsLC305 Number of Islands IILC547 Friend CirclesLC130 Surrounded Regions LC737 句子相似性IILC721, 账户合并">
<meta property="og:type" content="article">
<meta property="og:title" content="并查集">
<meta property="og:url" content="http://xyfu.me/posts/c517589e/index.html">
<meta property="og:site_name" content="Xuanyi Fu Blog">
<meta property="og:description" content="并查集主要用来解决动态连通性问题。连通性问题：LC200 Number of IslandsLC305 Number of Islands IILC547 Friend CirclesLC130 Surrounded Regions LC737 句子相似性IILC721, 账户合并">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-20T07:05:22.000Z">
<meta property="article:modified_time" content="2020-06-17T12:13:31.044Z">
<meta property="article:author" content="Xuanyi Fu">
<meta property="article:tag" content="并查集">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xyfu.me/posts/c517589e/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>并查集 | Xuanyi Fu Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xuanyi Fu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://xyfu.me/posts/c517589e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xuanyi Fu">
      <meta itemprop="description" content="Xuanyi Fu的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xuanyi Fu Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并查集
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-20 15:05:22" itemprop="dateCreated datePublished" datetime="2020-02-20T15:05:22+08:00">2020-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-17 20:13:31" itemprop="dateModified" datetime="2020-06-17T20:13:31+08:00">2020-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode/" itemprop="url" rel="index">
                    <span itemprop="name">LeetCode</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>并查集主要用来解决动态连通性问题。<br>连通性问题：<br><a href="https://xyfu.me/posts/c517589e/#%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98">LC200 Number of Islands</a><br><a href="https://xyfu.me/posts/c517589e/#%E5%8A%A8%E6%80%81%E8%BF%9E%E9%80%9A%E6%80%A7">LC305 Number of Islands II</a><br><a href="https://xyfu.me/posts/c517589e/#%E6%9C%8B%E5%8F%8B%E5%9C%88">LC547 Friend Circles</a><br><a href="https://xyfu.me/posts/c517589e/#%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F">LC130 Surrounded Regions</a></p>
<p><a href="https://xyfu.me/posts/c517589e/#%E5%8F%A5%E5%AD%90%E7%9B%B8%E4%BC%BC%E6%80%A7">LC737 句子相似性II</a><br><a href="https://xyfu.me/posts/c517589e/#%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6/">LC721, 账户合并</a></p>
<a id="more"></a>
<h1 id="实现并查集"><a href="#实现并查集" class="headerlink" title="实现并查集"></a>实现并查集</h1><p>Weighted Quick-Union with Path Compression</p>
<p>建议参考：<a href="https://algs4.cs.princeton.edu/lectures/15UnionFind.pdf" target="_blank" rel="noopener">Algorithm 4th edition, Union-Find</a></p>
<p>定义：</p>
<ul>
<li>一个节点<code>i</code>的父节点为<code>tree[i]</code></li>
<li>一个节点<code>i</code>所在的树的根节点<code>j</code>为父节点为自己的祖先节点，即<code>tree[j] == j</code>。</li>
</ul>
<p>初始化：</p>
<ul>
<li>所有的节点<code>i</code>的父节点为其自己，即初始化时赋值<code>tree[i] = i</code></li>
<li>因此，以所有节点<code>i</code>为根节点的集合（树）的初始化为<code>1</code></li>
</ul>
<p><code>find()</code>的实现思路：</p>
<ul>
<li>两个节点在一个集合（树）中，当且仅当他们的集合（树）的根节点是相同的。</li>
<li>Path compression: 每次在找到一个节点所在集合的根节点的过程中，将从根节点到该节点路径上的所有节点的父节点都设置为根节点。<br><code>union() / connect()</code>的实现思路：</li>
<li>要将两个节点合并，就是将他们所在的集合（树）合并。因此我们可以把其中一个集合（树）的根节点的父节点设置为另一个集合（树）的根节点。</li>
<li>Weighted Quick-Union: 我们记录以每一个节点为根节点的树的大小。我们总是将含有元素较少的集合（树）的根节点的父节点改为含有较多元素的集合（树）的根节点。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        实现1
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disjoint_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    disjoint_set(<span class="keyword">size_t</span> sz)</span><br><span class="line">    : tree(sz)</span><br><span class="line">    , size(sz, <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iota(tree.begin(), tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> find(<span class="keyword">size_t</span> idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; ids&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(idx != tree[idx])</span><br><span class="line">        &#123;</span><br><span class="line">            ids.push_back(idx);</span><br><span class="line">            idx = tree[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : ids) tree[x] = idx;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">size_t</span> idx1, <span class="keyword">size_t</span> idx2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rt1 = find(idx1);</span><br><span class="line">        <span class="keyword">auto</span> rt2 = find(idx2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rt1 == rt2) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(size[rt1] &lt; size[rt2]) </span><br><span class="line">            swap(rt1, rt2);</span><br><span class="line">        </span><br><span class="line">        tree[rt2] = rt1;</span><br><span class="line">        rt1 += size[rt2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_single_set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adjacent_find(tree.begin(), tree.end(), [<span class="keyword">this</span>](<span class="keyword">auto</span> lhs, <span class="keyword">auto</span> rhs)&#123;<span class="keyword">return</span> find(lhs) != find(rhs);&#125;) == tree.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        实现2
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">explicit UnionFind(T num):</span><br><span class="line">        tree(num),</span><br><span class="line">        size(num, <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    iota(tree.begin(), tree.end(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">find</span><span class="params">(T index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index] != index)</span><br><span class="line">        tree[index] = find(tree[index]);</span><br><span class="line">    <span class="keyword">return</span> tree[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(T idx1, T idx2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T root1 = find(idx1);</span><br><span class="line">    T root2 = find(idx2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root1 != root2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(size[root1] &lt; size[root2])</span><br><span class="line">        &#123;</span><br><span class="line">            tree[root1] = root2;</span><br><span class="line">            size[root2] += size[root1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[root2] = root1;</span><br><span class="line">            size[root1] += size[root2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; tree;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<h1 id="连通性问题"><a href="#连通性问题" class="headerlink" title="连通性问题"></a>连通性问题</h1><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">LC200, Number of Islands</a>, <a href="https://leetcode-cn.com/problems/number-of-islands-ii/" target="_blank" rel="noopener">LC305, Number of Islands II</a></p>
<p>其中第一题<a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">LC200, Number of Islands</a>不是动态的连通性问题，因此也可以用DFS来统计深度优先森林中树的个数或 用BFS来遍历。</p>
<p>思路1 并查集：</p>
<ul>
<li>将坐标<code>[i][j]</code>转换成唯一对应的<code>index = i * numCols + j</code>，作为并查集的<code>index</code></li>
<li>初始化一个同样大小的并查集和一个计数器<code>count=0</code>。</li>
<li>遍历矩阵，每次遇到<code>1</code>的时候<ul>
<li>增加计数器<code>++count</code></li>
<li>尝试合并这个元素<code>[i][j]</code>和他上方的元素<code>[i - 1][j]</code>以及他左边的元素<code>[i][j - 1]</code></li>
<li>如果这个元素和他上方的元素以及他左边的元素不在一个set里，那么减少计数器<code>--count</code>。因为：<ul>
<li>如果这个元素和其中一个元素连通了，没有增加岛屿的数量。</li>
<li>如果这个元素和两个都成功连通了，那么这个元素就将矩阵里原来的两个岛接在了一起。那么岛屿数量会<code>-1</code>。(<code>++count, --count, --count</code>)</li>
</ul>
</li>
</ul>
</li>
<li>返回计数器的值</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2020.6.17 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disjoint_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">disjoint_set</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line">    :m_tree(size)</span><br><span class="line">    ,m_size(size, <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iota(m_tree.begin(),  m_tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">root</span><span class="params">(<span class="keyword">size_t</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; indices&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(m_tree[index] != index)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(index);</span><br><span class="line">            index = m_tree[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// m_tree[index] == index, we find the root</span></span><br><span class="line">        <span class="comment">// then we do path compression</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> idx : indices)</span><br><span class="line">        &#123;</span><br><span class="line">            m_tree[idx] = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">connect</span><span class="params">(<span class="keyword">size_t</span> i, <span class="keyword">size_t</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i_root = root(i);</span><br><span class="line">        <span class="keyword">auto</span> j_root = root(j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fail to connect if they are in the same tree</span></span><br><span class="line">        <span class="keyword">if</span>(i_root == j_root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check which tree that i or j belongs to has greater size</span></span><br><span class="line">        <span class="keyword">if</span>(m_size[i_root] &lt; m_size[j_root])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i_root, j_root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_tree[j_root] = i_root;</span><br><span class="line">        m_size[i_root] += m_size[j_root];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> LAND = <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> WATER = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> uf = disjoint_set&#123;grid.size() * grid.front().size()&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> to_index = [&amp;](<span class="keyword">size_t</span> i, <span class="keyword">size_t</span> j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i * grid.front().size() + j;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> is_valid_land = [&amp;](<span class="keyword">size_t</span> i, <span class="keyword">size_t</span> j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">                i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> </span><br><span class="line">            &amp;&amp;  i &lt; grid.size() &amp;&amp; j &lt; grid.front().size() </span><br><span class="line">            &amp;&amp;  grid[i][j] == LAND;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">size_t</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; grid.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j = <span class="keyword">size_t</span>&#123;&#125;; j &lt; grid.front().size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == LAND)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    <span class="keyword">if</span>(is_valid_land(i - <span class="number">1</span>, j))</span><br><span class="line">                    &#123;</span><br><span class="line">                        res -= uf.connect(to_index(i, j), to_index(i - <span class="number">1</span>, j));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(is_valid_land(i, j - <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        res -= uf.connect(to_index(i, j), to_index(i, j - <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">explicit UnionFind(T num):</span><br><span class="line">        tree(num),</span><br><span class="line">        size(num, <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    iota(tree.begin(), tree.end(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">find</span><span class="params">(T index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index] != index)</span><br><span class="line">        tree[index] = find(tree[index]);</span><br><span class="line">    <span class="keyword">return</span> tree[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(T idx1, T idx2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T root1 = find(idx1);</span><br><span class="line">    T root2 = find(idx2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root1 != root2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(size[root1] &lt; size[root2])</span><br><span class="line">        &#123;</span><br><span class="line">            tree[root1] = root2;</span><br><span class="line">            size[root2] += size[root1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[root2] = root1;</span><br><span class="line">            size[root1] += size[root2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; tree;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid.front().empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assume it's ok to use int</span></span><br><span class="line">        nr = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(grid.size());</span><br><span class="line">        nc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(grid.front().size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span> = <span class="keyword">new</span> UnionFind&lt;<span class="keyword">int</span>&gt;&#123;nr * nc&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nr; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nc; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == ISLAND)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == ISLAND) </span><br><span class="line">                        connect(toIndex(i, j), toIndex(i - <span class="number">1</span>, j));</span><br><span class="line">                    <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == ISLAND)</span><br><span class="line">                        connect(toIndex(i, j), toIndex(i, j - <span class="number">1</span>));         </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">char</span> ISLAND = <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">int</span> nr;</span><br><span class="line">    <span class="keyword">int</span> nc;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    UnionFind&lt;<span class="keyword">int</span>&gt;* <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>-&gt;connect(idx1, idx2))</span><br><span class="line">        &#123;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">toIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i * nc + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<p>思路2: BFS</p>
<p>遍历所有节点，每当遇到<code>1</code>的节点时，计数器+1。之后从该节点开始进行BFS。BFS过程中，把所有遇到的节点都置<code>0</code>。<br><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> LAND  = <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> WATER = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> i;</span><br><span class="line">        <span class="keyword">size_t</span> j;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> is_valid_land = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pt.i &gt;=<span class="number">0</span> &amp;&amp; pt.j &gt;=<span class="number">0</span></span><br><span class="line">            &amp;&amp;     pt.i &lt; grid.size() &amp;&amp; pt.j &lt; grid.front().size()</span><br><span class="line">            &amp;&amp;     grid[pt.i][pt.j] == LAND;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> connected_poses = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span></span><br><span class="line">            &#123;</span><br><span class="line">                point&#123;pt.i + <span class="number">1</span>, pt.j&#125;,</span><br><span class="line">                point&#123;pt.i - <span class="number">1</span>, pt.j&#125;,</span><br><span class="line">                point&#123;pt.i, pt.j - <span class="number">1</span>&#125;,</span><br><span class="line">                point&#123;pt.i, pt.j + <span class="number">1</span>&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> set_water = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[pt.i][pt.j] = WATER;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> bfs = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> bfs_queue = <span class="built_in">queue</span>&lt;point&gt;&#123;&#125;;</span><br><span class="line">            set_water(pt);</span><br><span class="line">            bfs_queue.push(pt);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!bfs_queue.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> c_pt : connected_poses( bfs_queue.front() ))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(is_valid_land(c_pt))</span><br><span class="line">                    &#123;</span><br><span class="line">                        set_water(c_pt);</span><br><span class="line">                        bfs_queue.push(c_pt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bfs_queue.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> res = <span class="keyword">size_t</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; grid.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j = <span class="keyword">size_t</span>&#123;&#125;; j &lt; grid.front().size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == LAND)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    bfs(point&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div></p>
<hr>
<h2 id="朋友圈"><a href="#朋友圈" class="headerlink" title="朋友圈"></a>朋友圈</h2><p><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">LC547 Friend Circles</a><br>同上两题。这个题可以利用无向图邻接矩阵的对称性，不需要遍历矩阵所有部分。只需要遍历右上角即可。</p>
<p>在并查集里统计不交集的个数。开始时不交集的个数等于节点的个数。每次成功合并两个不交集，都会使得不交集的个数减1。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2020.6.17 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disjoint_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">disjoint_set</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line">    :m_tree(size)</span><br><span class="line">    ,m_size(size, <span class="number">1</span>)</span><br><span class="line">    ,m_set_num&#123;size&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        iota(m_tree.begin(),  m_tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">root</span><span class="params">(<span class="keyword">size_t</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; indices&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(m_tree[index] != index)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(index);</span><br><span class="line">            index = m_tree[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// m_tree[index] == index, we find the root</span></span><br><span class="line">        <span class="comment">// then we do path compression</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> idx : indices)</span><br><span class="line">        &#123;</span><br><span class="line">            m_tree[idx] = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">set_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_set_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">connect</span><span class="params">(<span class="keyword">size_t</span> i, <span class="keyword">size_t</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i_root = root(i);</span><br><span class="line">        <span class="keyword">auto</span> j_root = root(j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fail to connect if they are in the same tree</span></span><br><span class="line">        <span class="keyword">if</span>(i_root == j_root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check which tree that i or j belongs to has greater size</span></span><br><span class="line">        <span class="keyword">if</span>(m_size[i_root] &lt; m_size[j_root])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i_root, j_root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_tree[j_root] = i_root;</span><br><span class="line">        m_size[i_root] += m_size[j_root];</span><br><span class="line">        --m_set_num;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_size;</span><br><span class="line">    <span class="keyword">size_t</span> m_set_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> uf = disjoint_set&#123;M.size()&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; M.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j = <span class="keyword">size_t</span>&#123;i&#125; + <span class="number">1</span>; j &lt; M.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uf.connect(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uf.set_num();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ufset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ufset(<span class="keyword">int</span> num)</span><br><span class="line">    :tree(num)</span><br><span class="line">    ,size(num, <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iota(tree.begin(), tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[idx] != idx)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[idx] = find(tree[idx]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt1 = find(idx1);</span><br><span class="line">        <span class="keyword">int</span> rt2 = find(idx2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rt1 == rt2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size[rt1] &lt; size[rt2])</span><br><span class="line">        &#123;</span><br><span class="line">            tree[rt1] = rt2;</span><br><span class="line">            size[rt2] += size[rt1]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// size[rt1] &gt;= size[rt2]</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[rt2] = rt1;</span><br><span class="line">            size[rt1] += size[rt2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M.empty() || M.front().empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line">        <span class="keyword">size_t</span> N = M.size();</span><br><span class="line">        <span class="keyword">int</span> count = N;</span><br><span class="line">        <span class="function">ufset <span class="title">uf</span><span class="params">(N)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = i + <span class="number">1</span>; j &lt; N; ++j)</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == M[i][j] &amp;&amp; uf.connect(i, j))</span><br><span class="line">                   --count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="账户合并"><a href="#账户合并" class="headerlink" title="账户合并"></a>账户合并</h2><hr>
<p><a href="https://leetcode-cn.com/problems/accounts-merge/" target="_blank" rel="noopener">LC721, 账户合并</a></p>
<ul>
<li>按列表中的元素个数，建立一个相同大小的并查集。列表中元素的索引，即是其在并查集中的索引。</li>
<li>建立一个由【邮箱】到【索引】的<code>unordered_map</code> : <code>mail_index_map</code>。</li>
<li>遍历所有的邮箱：<ul>
<li>如果在<code>mail_index_map</code>中没有找到对应的【索引】，则建立对应关系。</li>
<li>如果在<code>mail_index_map</code>中找到了对应的【索引】，则出现了重复的邮箱。那么这个【邮箱】所对应的索引，应该和原来的【索引】合并。在并查集中<code>connect</code>对应的【索引】</li>
</ul>
</li>
<li>建立一个由【索引】到【邮箱集合】(<code>set</code>)的<code>unordered_map</code>。</li>
<li>遍历所有的【索引】，在并查集中找到他们的<code>root</code>。将该【索引】下的所有邮箱放入<code>root</code>对应的【邮箱集合】中。</li>
<li>遍历由【索引】到【邮箱集合】的<code>map</code>，生成结果。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disjoint_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">disjoint_set</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line">    :m_tree(size)</span><br><span class="line">    ,m_size(size, <span class="number">1</span>)</span><br><span class="line">    ,m_set_num&#123;size&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        iota(m_tree.begin(),  m_tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">root</span><span class="params">(<span class="keyword">size_t</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; indices&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(m_tree[index] != index)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(index);</span><br><span class="line">            index = m_tree[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// m_tree[index] == index, we find the root</span></span><br><span class="line">        <span class="comment">// then we do path compression</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> idx : indices)</span><br><span class="line">        &#123;</span><br><span class="line">            m_tree[idx] = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">set_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_set_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">connect</span><span class="params">(<span class="keyword">size_t</span> i, <span class="keyword">size_t</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i_root = root(i);</span><br><span class="line">        <span class="keyword">auto</span> j_root = root(j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fail to connect if they are in the same tree</span></span><br><span class="line">        <span class="keyword">if</span>(i_root == j_root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check which tree that i or j belongs to has greater size</span></span><br><span class="line">        <span class="keyword">if</span>(m_size[i_root] &lt; m_size[j_root])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i_root, j_root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_tree[j_root] = i_root;</span><br><span class="line">        m_size[i_root] += m_size[j_root];</span><br><span class="line">        --m_set_num;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_size;</span><br><span class="line">    <span class="keyword">size_t</span> m_set_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="keyword">auto</span> mail_index_map = <span class="built_in">unordered_map</span>&lt;string_view, <span class="keyword">size_t</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> index_uf = disjoint_set&#123;accounts.size()&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; accounts.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = ++accounts[i].begin(); it != accounts[i].end(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> mail_view = string_view&#123;it-&gt;data(), it-&gt;size()&#125;;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">auto</span> it = mail_index_map.find(mail_view);</span><br><span class="line">                it == mail_index_map.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    mail_index_map[mail_view] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    index_uf.connect(i, it-&gt;second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> index_mail_map = <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">set</span>&lt;string_view&gt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; accounts.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> root = index_uf.root(i);</span><br><span class="line">            index_mail_map[root].insert(++accounts[i].begin(), accounts[i].end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        transform(index_mail_map.begin(), index_mail_map.end(), back_inserter(res), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> vec = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;&#125;;</span><br><span class="line">            vec.push_back(accounts[pair.first][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> mail : pair.second)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.emplace_back(mail);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h2><p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">LC130, Surrounded Regions</a></p>
<p>这个题更适合用DFS，而不是并查集。DFS不需要遍历所有的元素，只生成从边界上的<code>&#39;O&#39;</code>出发的深度优先森林即可。<br>并查集的思路：</p>
<pre><code>- 设置哨兵元素`edgeGuard`
- 按从上到下、从左到右的顺序遍历矩阵每一个元素：
    - 如果是边界上的元素，那么把他和`edgeGurad`合并
    - 和左边元素、上边元素合并。
- 寻找所有O的root，不是`edgeGuard`的就改成`X`
</code></pre><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2020.6.17 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disjoint_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">disjoint_set</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line">    :m_tree(size, 0)</span><br><span class="line">    ,m_size(size, <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iota(m_tree.begin(), m_tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto root(size_t idx) -&gt; size_t</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> indices = <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(m_tree[idx] != idx)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(idx);</span><br><span class="line">            idx = m_tree[idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> index : indices)</span><br><span class="line">        &#123;</span><br><span class="line">            m_tree[index] = idx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto connect(size_t i, size_t j) -&gt; bool</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> root_i = root(i);</span><br><span class="line">        <span class="keyword">auto</span> root_j = root(j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root_i == root_j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_size[root_i] &lt; m_size[root_j])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(root_i, root_j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_tree[root_j] = root_i;</span><br><span class="line">        m_size[root_i] += m_size[root_j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board.front().empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">size_t</span> x;</span><br><span class="line">            <span class="keyword">size_t</span> y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">decltype</span>(<span class="keyword">auto</span>) adjacent()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">array</span></span><br><span class="line">                &#123;</span><br><span class="line">                    point&#123;x + <span class="number">1</span>, y&#125;,</span><br><span class="line">                    point&#123;x - <span class="number">1</span>, y&#125;,</span><br><span class="line">                    point&#123;x, y + <span class="number">1</span>&#125;,</span><br><span class="line">                    point&#123;x, y - <span class="number">1</span>&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> is_on_boundary = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pt.x == <span class="number">0</span> || pt.y == <span class="number">0</span> </span><br><span class="line">            || pt.x == board.size() - <span class="number">1</span> || pt.y == board.front().size() - <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> is_valid_point = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pt.x &gt;= <span class="number">0</span> &amp;&amp; pt.y &gt;= <span class="number">0</span> </span><br><span class="line">            &amp;&amp; pt.x &lt; board.size() &amp;&amp; pt.y &lt; board.front().size();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> to_index = [&amp;](point pt) -&gt; <span class="keyword">size_t</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pt.x * board.front().size() + pt.y;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> guard_index = board.size() * board.front().size();</span><br><span class="line">        <span class="keyword">auto</span> uf = disjoint_set&#123;guard_index + <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; board.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j = <span class="keyword">size_t</span>&#123;&#125;; j &lt; board.front().size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> p = point&#123;i, j&#125;;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(is_on_boundary(p))</span><br><span class="line">                    &#123;</span><br><span class="line">                        uf.connect(to_index(p), guard_index);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> pt : p.adjacent())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(is_valid_point(pt) &amp;&amp; board[pt.x][pt.y] == <span class="string">'O'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            uf.connect(to_index(pt), to_index(p));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; board.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j = <span class="keyword">size_t</span>&#123;&#125;; j &lt; board.front().size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span> </span><br><span class="line">                &amp;&amp; uf.root(to_index(point&#123;i, j&#125;)) != uf.root(guard_index))</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ufs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ufs(<span class="keyword">size_t</span> num);</span><br><span class="line">    <span class="keyword">size_t</span> find(<span class="keyword">size_t</span> idx);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">size_t</span> idx1, <span class="keyword">size_t</span> idx2)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ufs::ufs(<span class="keyword">size_t</span> num)</span><br><span class="line">        :tree(num)</span><br><span class="line">        ,size(num, <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    iota(tree.begin(), tree.end(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> ufs::find(<span class="keyword">size_t</span> idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx] != idx) tree[idx] = find(tree[idx]);</span><br><span class="line">    <span class="keyword">return</span> tree[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ufs::connect(<span class="keyword">size_t</span> idx1, <span class="keyword">size_t</span> idx2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> rt1 = find(idx1);</span><br><span class="line">    <span class="keyword">size_t</span> rt2 = find(idx2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rt1 == rt2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size[rt1] &lt; size[rt2])</span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt1] = rt2;</span><br><span class="line">        size[rt2] += size[rt1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//size[rt1] &gt;= size[rt2]</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt2] = rt1;</span><br><span class="line">        size[rt1] += size[rt2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">char</span> LETTER_O = <span class="string">'O'</span>;</span><br><span class="line">    <span class="keyword">size_t</span> numRow;</span><br><span class="line">    <span class="keyword">size_t</span> numCol;</span><br><span class="line">    <span class="keyword">size_t</span> guard;</span><br><span class="line">    ufs* uf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> size_t <span class="title">toIndex</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">size_t</span> x1, <span class="keyword">size_t</span> y1, <span class="keyword">size_t</span> x2, <span class="keyword">size_t</span> y2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectGuard</span><span class="params">(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Solution::connect(<span class="keyword">size_t</span> x1, <span class="keyword">size_t</span> y1, <span class="keyword">size_t</span> x2, <span class="keyword">size_t</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    uf-&gt;connect(toIndex(x1, y1), toIndex(x2, y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Solution::connectGuard(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    uf-&gt;connect(guard, toIndex(x, y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> Solution::toIndex(<span class="keyword">size_t</span> x, <span class="keyword">size_t</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * numCol + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Solution::solve(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.empty() || board.front().empty()) <span class="keyword">return</span>;</span><br><span class="line">    numRow = board.size();</span><br><span class="line">    numCol = board.front().size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize ufs</span></span><br><span class="line">    guard = numRow * numCol;</span><br><span class="line">    uf = <span class="keyword">new</span> ufs&#123;guard + <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numRow; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; numCol; ++j)</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == LETTER_O)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if it is on the edge</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || i == numRow - <span class="number">1</span> || j == numCol - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//connect it with the gurad</span></span><br><span class="line">                    connectGuard(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; LETTER_O == board[i - <span class="number">1</span>][j])</span><br><span class="line">                    connect(i, j, i - <span class="number">1</span>, j);</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; LETTER_O == board[i][j - <span class="number">1</span>])</span><br><span class="line">                    connect(i, j, i, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numRow; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; numCol; ++j)</span><br><span class="line">            <span class="keyword">if</span> (uf-&gt;find(toIndex(i,j)) != uf-&gt;find(guard))</span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="句子相似性"><a href="#句子相似性" class="headerlink" title="句子相似性"></a>句子相似性</h2><p><a href="https://leetcode-cn.com/problems/sentence-similarity-ii/" target="_blank" rel="noopener">LC737 句子相似性II</a></p>
<p>并查集的简单应用。需要注意的：</p>
<ul>
<li>句子中会有下面相似单词中没有的单词。</li>
<li>如果出现没有的单词，也不可以马上认为句子不相似。因为如果这两个没有的单词可能是完全相同的。</li>
</ul>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disjoint_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">disjoint_set</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line">    :m_tree(size, 0)</span><br><span class="line">    ,m_size(size, <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iota(m_tree.begin(), m_tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto root(size_t idx) -&gt; size_t</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> indices = <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(m_tree[idx] != idx)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(idx);</span><br><span class="line">            idx = m_tree[idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> index : indices)</span><br><span class="line">        &#123;</span><br><span class="line">            m_tree[index] = idx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto connect(size_t i, size_t j) -&gt; bool</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> root_i = root(i);</span><br><span class="line">        <span class="keyword">auto</span> root_j = root(j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root_i == root_j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m_size[root_i] &lt; m_size[root_j])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(root_i, root_j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_tree[root_j] = root_i;</span><br><span class="line">        m_size[root_i] += m_size[root_j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words2, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; pairs)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words1.size() != words2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> word_index_map = <span class="built_in">unordered_map</span>&lt;string_view, <span class="keyword">size_t</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> word_num = [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> index = <span class="keyword">size_t</span>&#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : pairs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(string_view word : pair)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">auto</span> it = word_index_map.find(word);</span><br><span class="line">                        it == word_index_map.end())</span><br><span class="line">                    &#123;</span><br><span class="line">                        word_index_map[word] = index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> word_index_map.size();</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> uf = disjoint_set&#123;word_num&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : pairs)</span><br><span class="line">        &#123;</span><br><span class="line">            uf.connect(word_index_map[pair[<span class="number">0</span>]],word_index_map[pair[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mismatch(words1.begin(), words1.end(), words2.begin(), </span><br><span class="line">        [&amp;](string_view word1, string_view word2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1 == word2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(word_index_map.find(word1) == word_index_map.end() || </span><br><span class="line">               word_index_map.find(word2) == word_index_map.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> uf.root(word_index_map[word1]) == uf.root(word_index_map[word2]);</span><br><span class="line">        &#125;) == make_pair(words1.end(), words2.end());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<hr>
<h2 id="动态连通性"><a href="#动态连通性" class="headerlink" title="动态连通性"></a>动态连通性</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands-ii/" target="_blank" rel="noopener">LC305, Number of Islands II</a></p>
<p>动态连通性问题，同上题，维护一个并查集即可。 需要注意的问题是：测试用例中有positions中有重复的坐标，需要判断并跳过。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        2020.6.17 code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">disjoint_set</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">disjoint_set</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line">    :m_tree(size)</span><br><span class="line">    ,m_size(size, <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iota(m_tree.begin(),  m_tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">root</span><span class="params">(<span class="keyword">size_t</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; indices&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(m_tree[index] != index)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.push_back(index);</span><br><span class="line">            index = m_tree[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// m_tree[index] == index, we find the root</span></span><br><span class="line">        <span class="comment">// then we do path compression</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> idx : indices)</span><br><span class="line">        &#123;</span><br><span class="line">            m_tree[idx] = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">connect</span><span class="params">(<span class="keyword">size_t</span> i, <span class="keyword">size_t</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i_root = root(i);</span><br><span class="line">        <span class="keyword">auto</span> j_root = root(j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fail to connect if they are in the same tree</span></span><br><span class="line">        <span class="keyword">if</span>(i_root == j_root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check which tree that i or j belongs to has greater size</span></span><br><span class="line">        <span class="keyword">if</span>(m_size[i_root] &lt; m_size[j_root])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(i_root, j_root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_tree[j_root] = i_root;</span><br><span class="line">        m_size[i_root] += m_size[j_root];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numIslands2(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">auto</span> <span class="title">adjacent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">array</span></span><br><span class="line">                &#123;</span><br><span class="line">                    point&#123;x + <span class="number">1</span>, y&#125;,</span><br><span class="line">                    point&#123;x - <span class="number">1</span>, y&#125;,</span><br><span class="line">                    point&#123;x, y + <span class="number">1</span>&#125;,</span><br><span class="line">                    point&#123;x, y - <span class="number">1</span>&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(positions.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> grid = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">auto</span> uf = disjoint_set&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(m * n)&#125;;</span><br><span class="line">        <span class="keyword">auto</span> is_valid_land = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pt.x &gt;= <span class="number">0</span> &amp;&amp; pt.y &gt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; pt.x &lt; m &amp;&amp; pt.y &lt; n</span><br><span class="line">            &amp;&amp; grid[pt.x][pt.y] == <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> to_index = [&amp;](point pt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(pt.x * n + pt.y);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cnt = <span class="keyword">int</span>&#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pos : positions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pt = point&#123;pos[<span class="number">0</span>], pos[<span class="number">1</span>]&#125;;</span><br><span class="line">            <span class="keyword">if</span>(grid[pt.x][pt.y] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(res.back());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[pt.x][pt.y] = <span class="number">1</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> adj : pt.adjacent())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(is_valid_land(adj) &amp;&amp; uf.connect(to_index(adj), to_index(pt)))</span><br><span class="line">                &#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line">            :tree(num)</span><br><span class="line">            ,size(num,<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iota(tree.begin(), tree.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> UnionFind::find(<span class="keyword">int</span> idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx] != idx)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[idx] = find(tree[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> UnionFind::connect(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> rt1 = find(idx1);</span><br><span class="line">    <span class="keyword">int</span> rt2 = find(idx2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rt1 == rt2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size[rt1] &lt; size[rt2])</span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt1] = rt2;</span><br><span class="line">        size[rt2] += size[rt1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt2] = rt1;</span><br><span class="line">        size[rt1] += size[rt2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> numRow;</span><br><span class="line">    <span class="keyword">int</span> numCol;</span><br><span class="line">    UnionFind* <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;* mat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>-&gt;connect(x1 * numCol + y1, x2 * numCol + y2) )</span><br><span class="line">            --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numIslands2(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions) &#123;</span><br><span class="line">        <span class="comment">// initilize</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        numRow = m;</span><br><span class="line">        numCol = n;</span><br><span class="line">        <span class="built_in">set</span> = <span class="keyword">new</span> UnionFind&#123;numRow * numCol&#125;;</span><br><span class="line">        mat = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;(numRow, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(numCol, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pos : positions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = pos.front();</span><br><span class="line">            <span class="keyword">int</span> y = pos.back();</span><br><span class="line">            <span class="comment">// check if duplicated</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == (*mat)[x][y])</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(count);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            (*mat)[x][y] = <span class="number">1</span>;</span><br><span class="line">            ++count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">0</span> &amp;&amp; <span class="number">1</span> == (*mat)[x - <span class="number">1</span>][y])</span><br><span class="line">            &#123;</span><br><span class="line">                connect(x, y, x<span class="number">-1</span>, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y != <span class="number">0</span> &amp;&amp; <span class="number">1</span> == (*mat)[x][y - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                connect(x, y, x, y - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x != m - <span class="number">1</span> &amp;&amp; <span class="number">1</span> == (*mat)[x + <span class="number">1</span>][y])</span><br><span class="line">            &#123;</span><br><span class="line">                connect(x, y, x + <span class="number">1</span>, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y != n - <span class="number">1</span> &amp;&amp; <span class="number">1</span> == (*mat)[x][y + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                connect(x, y, x, y + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.push_back(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">delete</span> mat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag"># 并查集</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/69854dca/" rel="prev" title="文章索引">
      <i class="fa fa-chevron-left"></i> 文章索引
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/f92eff5d/" rel="next" title="回溯">
      回溯 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#实现并查集"><span class="nav-number">1.</span> <span class="nav-text">实现并查集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连通性问题"><span class="nav-number">2.</span> <span class="nav-text">连通性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#岛屿数量"><span class="nav-number">2.1.</span> <span class="nav-text">岛屿数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#朋友圈"><span class="nav-number">2.2.</span> <span class="nav-text">朋友圈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#账户合并"><span class="nav-number">2.3.</span> <span class="nav-text">账户合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#被围绕的区域"><span class="nav-number">2.4.</span> <span class="nav-text">被围绕的区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#句子相似性"><span class="nav-number">2.5.</span> <span class="nav-text">句子相似性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态连通性"><span class="nav-number">2.6.</span> <span class="nav-text">动态连通性</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xuanyi Fu</p>
  <div class="site-description" itemprop="description">Xuanyi Fu的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xuanyi-fu" title="GitHub → https://github.com/xuanyi-fu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5300073738" title="Weibo → https://weibo.com/5300073738" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xuanyi Fu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">130k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">1:58</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
