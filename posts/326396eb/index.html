<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xyfu.me').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="类型双关(type punning)经常在需要高性能的代码和网络编程中出现。比如：  利用强制类型转换，将float和int互相转换。 将malloc申请来的内存指针void *强制类型转换为一个对象的指针类型X *，并通过该指针访问X的成员。  然而，C++中的大部分的type punning（包括以上的两种）都会导致undefined behaviour。我们将解决以下问题：  type pu">
<meta property="og:type" content="article">
<meta property="og:title" content="Type Punning">
<meta property="og:url" content="http://xyfu.me/posts/326396eb/index.html">
<meta property="og:site_name" content="Xuanyi Fu Blog">
<meta property="og:description" content="类型双关(type punning)经常在需要高性能的代码和网络编程中出现。比如：  利用强制类型转换，将float和int互相转换。 将malloc申请来的内存指针void *强制类型转换为一个对象的指针类型X *，并通过该指针访问X的成员。  然而，C++中的大部分的type punning（包括以上的两种）都会导致undefined behaviour。我们将解决以下问题：  type pu">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-06T07:44:56.000Z">
<meta property="article:modified_time" content="2020-07-07T14:19:22.861Z">
<meta property="article:author" content="Xuanyi Fu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xyfu.me/posts/326396eb/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Type Punning | Xuanyi Fu Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xuanyi Fu Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://xyfu.me/posts/326396eb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Xuanyi Fu">
      <meta itemprop="description" content="Xuanyi Fu的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xuanyi Fu Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Type Punning
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-06 15:44:56" itemprop="dateCreated datePublished" datetime="2020-07-06T15:44:56+08:00">2020-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-07 22:19:22" itemprop="dateModified" datetime="2020-07-07T22:19:22+08:00">2020-07-07</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.9k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>类型双关(type punning)经常在需要高性能的代码和网络编程中出现。比如：</p>
<ul>
<li>利用强制类型转换，将<code>float</code>和<code>int</code>互相转换。</li>
<li>将<code>malloc</code>申请来的内存指针<code>void *</code>强制类型转换为一个对象的指针类型<code>X *</code>，并通过该指针访问<code>X</code>的成员。</li>
</ul>
<p>然而，C++中的大部分的type punning（包括以上的两种）都会导致undefined behaviour。<br>我们将解决以下问题：</p>
<ul>
<li>type punning 会导致怎样的undefined behaviour?</li>
<li>type punning 为何会导致undefined behaviour?</li>
<li>哪些type punning是正确的，哪些是错误的？</li>
<li>当我们必须进行type punning时，如何避免undefined behaviour来实现type punning的功能？</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=_qzMpk-22cc" target="_blank" rel="noopener">CppCon 2019: Timur Doumler “Type punning in modern C++”</a></p>
<a id="more"></a>
<h1 id="会导致怎样的ub"><a href="#会导致怎样的ub" class="headerlink" title="会导致怎样的ub"></a>会导致怎样的ub</h1><p>Example for twitter: @lunasorcery<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Widget"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gizmo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doSomethingCompleteDifferent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Gizmo"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Gizmo g;</span><br><span class="line">	Widget* w = <span class="keyword">reinterpret_cast</span>&lt;Widget*&gt;(&amp;g);</span><br><span class="line">	w-&gt;doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码在clang和gcc都可以编译，但是却产生了UB：<br>在x86-64 clang10.0，<code>-O3</code>优化下，这段代码会打印出<code>Gizmo</code><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span>                                   # @main</span><br><span class="line">        <span class="keyword">push</span>    <span class="built_in">rax</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, offset .L.str</span><br><span class="line">        <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">call</span>    printf</span><br><span class="line">        <span class="keyword">xor</span>     <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line">        <span class="keyword">pop</span>     <span class="built_in">rcx</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.L.str:</span></span><br><span class="line"><span class="meta">        .asciz</span>  <span class="string">"Gizmo"</span></span><br></pre></td></tr></table></figure><br>在x86-64 gcc10.1，<code>-O3</code>优化下，这段代码被编译器全部忽略：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br></pre></td></tr></table></figure><br>在gcc看来，<code>g</code>是一个<code>Gizmo</code>而不是一个<code>Widget</code>，<code>Gizmo</code>和<code>Widget</code>又无继承关系，不可能在<code>g</code>上调用<code>Widge</code>的成员函数<code>doSomething()</code>。因此gcc将第23行的代码直接优化掉。</p>
<h1 id="为什么会导致ub"><a href="#为什么会导致ub" class="headerlink" title="为什么会导致ub"></a>为什么会导致ub</h1><p>错误地进行type punning可能会导致代码违反以下四种规则：</p>
<ul>
<li>aliasing rules</li>
<li>object lifetime rules</li>
<li>alignment rules</li>
<li>rules for valid value representations</li>
</ul>
<h2 id="aliasing-rules"><a href="#aliasing-rules" class="headerlink" title="aliasing rules"></a>aliasing rules</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *a = <span class="number">1</span>;</span><br><span class="line">  *b = <span class="number">2</span>;</span><br><span class="line">  *a += *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// legal</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  test(&amp;a, &amp;b);</span><br><span class="line">  <span class="keyword">return</span> a;         <span class="comment">// a == 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// legal</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  test(&amp;a, &amp;a);</span><br><span class="line">  <span class="keyword">return</span> a;        <span class="comment">// a == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子当中，调用<code>f1()</code>会返回3，调用<code>f2()</code>会返回4。注意到在<code>f2()</code>调用<code>test(&amp;a, &amp;a)</code>时，两个指针同时指向了<code>a</code>。gcc生成的汇编如下<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>*):</span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rdi</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsi</span>], <span class="number">2</span></span><br><span class="line">        <span class="keyword">add</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rdi</span>], <span class="number">2</span></span><br><span class="line">        <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>但是在fortran当中，不允许两个引用引用到相同的地址。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> test(a, b)</span><br><span class="line">  <span class="keyword">integer</span>, <span class="keyword">integer</span>(inout) :: a, b</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  a = a + b</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> test</span><br></pre></td></tr></table></figure>
<p>gcc生成的汇编如下，因为预先知道了<code>a</code>和<code>b</code>不会是相同地址的引用，生成的代码更加简洁。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">test_:</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rsi</span>], <span class="number">2</span></span><br><span class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rdi</span>], <span class="number">3</span></span><br><span class="line">        <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>编译器在知道<code>a</code>和<code>b</code>不是相同地址的前提下，看到了对<code>a</code>和<code>b</code>的赋值。并且了解到在<code>a = a + b</code>之前，<code>a</code>的值一直都是1，因此编译器就可以调整语句顺序，直接将3赋值给<code>a</code>。</p>
<p>但是在C++中允许这样的aliasing(即<code>a</code>和<code>b</code>指向相同的地址)，所以我们就不能作出像fortran一样的优化。然而编译器不可能假设任何指针之间都有aliasing关系，否则C++生成的代码会变得非常缓慢。我们需要在 aliasing 和 效率 之间找到一个平衡点，这个就是C++的aliasing rule。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">float</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *a = <span class="number">1</span>;</span><br><span class="line">  *b = <span class="number">2</span>;</span><br><span class="line">  *a += <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(*b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// violation of aliasing rule</span></span><br><span class="line">  test(&amp;x, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">float</span>*&gt;(&amp;x));</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，<code>a</code>和<code>b</code>的类型是不相关的，因此编译器可以假设<code>a</code>和<code>b</code>没有aliasing关系，进行更好的优化。<br>然而在<code>main()</code>函数中调用<code>test()</code>函数时，违反了aliasing rule。这段代码会在假设<code>a</code>和<code>b</code>指向不相同地址的假设下编译，如果用相同的地址调用，就产生的UB。</p>
<p>关于C++的strict aliasing rule，可以阅读这篇文章<a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8" target="_blank" rel="noopener">What is the Strict Aliasing Rule and Why do we care?</a></p>
<h2 id="object-lifetime-rules"><a href="#object-lifetime-rules" class="headerlink" title="object lifetime rules"></a>object lifetime rules</h2><p>标准中关于object lifetime的定义：</p>
<blockquote>
<p>The lifetime of an object or reference is a runtime property of the object or reference. A variable is said to have vacuous initialization if it is default-initialized and, if it is of class type or a (possibly multi-dimensional) array thereof, that class type has a trivial default constructor. The lifetime of an object of type T begins when:</p>
<ul>
<li>(1.1) — storage with the proper alignment and size for type T is obtained, and</li>
<li>(1.2) — its <strong>initialization (if any) is complete</strong> (including vacuous initialization) (9.4), except that if the object is a union member or subobject thereof, its lifetime only begins if that union member is the initialized member in the union (9.4.1, 11.10.2), or as described in 11.5 and 11.4.4.2, and except as described in 20.10.10.1. The lifetime of an object o of type T ends when:</li>
<li>(1.3) — if T is a non-class type, the object is destroyed, or</li>
<li>(1.4) — if T is a class type, the destructor call starts, or</li>
<li>(1.5) — the storage which the object occupies is released, or is reused by an object that is not nested within<br>o (6.7.2).</li>
</ul>
</blockquote>
<p>在已经对一个对象分配好存储空间后，一个对象的lifetime开始前，对于一个对象的指针使用有着以下限制：</p>
<blockquote>
<p>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated29 or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that represents the address of the storage location where the object will be or was located may be used but only in limited ways. For an object under construction or destruction,<br>see 11.10.4. Otherwise, such a pointer refers to allocated storage (6.7.5.4.1), and using the pointer as if the pointer were of type void* is well-defined. Indirection through such a pointer is permitted but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:</p>
<ul>
<li>(6.1) — the object will be or was of a class type with a non-trivial destructor and the pointer is used as the operand of a delete-expression,</li>
<li>(6.2) — the pointer is used to access a non-static data member or call a non-static member function of the object, or</li>
<li>(6.3) — the pointer is implicitly converted (7.3.11) to a pointer to a virtual base class, or</li>
<li>(6.4) — the pointer is used as the operand of a static_cast (7.6.1.8), except when the conversion is to pointer to cv void, or to pointer to cv void and subsequently to pointer to cv char, cv unsigned char, or cv std::byte (17.2.1), or</li>
<li>(6.5) — the pointer is used as the operand of a dynamic_cast (7.6.1.6).</li>
</ul>
</blockquote>
<p>同样地，在上述情况下，对一个对象的引用也有以下限制</p>
<blockquote>
<p>Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways.<br>For an object under construction or destruction, see 11.10.4. Otherwise, such a glvalue refers to allocated storage (6.7.5.4.1), and using the properties of the glvalue that do not depend on its value is well-defined. The program has undefined behavior if:</p>
<ul>
<li>(7.1) — the glvalue is used to access the object, or</li>
<li>(7.2) — the glvalue is used to call a non-static member function of the object, or</li>
<li>(7.3) — the glvalue is bound to a reference to a virtual base class (9.4.3), or</li>
<li>(7.4) — the glvalue is used as the operand of a dynamic_cast (7.6.1.6) or as the operand of typeid.</li>
</ul>
</blockquote>
<p>那么如果产生一个object呢？</p>
<blockquote>
<p> An object is created by a definition (6.2), by a new-expression (7.6.2.7), by an operation that implicitly creates objects (see below), when implicitly changing the active member of a union (11.5), or when a temporary object is created (7.3.4, 6.7.7)</p>
</blockquote>
<hr>
<p>例子1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">make_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X* p = (X*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct X)); <span class="comment">//UB</span></span><br><span class="line">  p-&gt;a = <span class="number">1</span>;</span><br><span class="line">  p-&gt;b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意在注释有<code>//UB</code>的一行，X所指的对象处于”the lifetime of an object has started but after the storage which the object will occupy has been allocated”所描述的状态。即虽然已经分配了储存空间，但是却未调用X的构造函数。后续的操作为UB。</p>
<hr>
<p>修复例子1中的错误可以使用placement new。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">make_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* storage = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="keyword">sizeof</span>(X)];</span><br><span class="line">  X* p = <span class="keyword">new</span>(storage) X; <span class="comment">// ctor is called, object is created</span></span><br><span class="line">  p-&gt;a = <span class="number">1</span>;</span><br><span class="line">  p-&gt;b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="alignment-rules"><a href="#alignment-rules" class="headerlink" title="alignment rules"></a>alignment rules</h2><p>继续前面object lifetime中例子1的修复，我们是否可以将storage放在栈上呢？<br>例子2：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">make_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> storage[<span class="keyword">sizeof</span>(X)];</span><br><span class="line">  X* p = <span class="keyword">new</span>(storage) X;</span><br><span class="line">  p-&gt;a = <span class="number">1</span>;</span><br><span class="line">  p-&gt;b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不可以，因为这违反了alignment rules。</p>
<hr>
<p>标准中关于alignment rules的说明：</p>
<blockquote>
<p>Object types have alignment requirements (6.8.1, 6.8.2) which place restrictions on the addresses at which an object of that type may be allocated.  An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated. An object type imposes an alignment requirement on every object of that type; stricter alignment can be requested using the alignment specifier.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      64bit Machine</span><br><span class="line"></span><br><span class="line">      An int32_t with false alignment +-------+</span><br><span class="line">                                              |</span><br><span class="line">+----+An int32_t with correct alignment       |</span><br><span class="line">|                                             |</span><br><span class="line">|                                             |</span><br><span class="line">|     +--+--+--+--+--+--+--+--+               |</span><br><span class="line">|     |  |  |  |  |  |  |  |  |               |</span><br><span class="line">|     +-----------------------+               |</span><br><span class="line">|     |  |  |  |  |  |  |  |  |               |</span><br><span class="line">|     +-----------------------+               |</span><br><span class="line">+----&gt;+AA|AA|AA|AA|  |  |  |  |               |</span><br><span class="line">      +-----------------------+               |</span><br><span class="line">      |  |  |  |  |  |  |AA|AA+&lt;--------------+</span><br><span class="line">      +-----------------------+</span><br><span class="line">      |AA|AA|  |  |  |  |  |  |</span><br><span class="line">      +-----------------------+</span><br><span class="line">      |  |  |  |  |  |  |  |AA+&lt;--------------+</span><br><span class="line">      +-----------------------+               |</span><br><span class="line">      |AA|  |  |  |  |  |  |  |               |</span><br><span class="line">      +-----+--+--+--+--+--+--+               |</span><br><span class="line">                                              |</span><br><span class="line">     a char[2] array with correct alignment +-+</span><br></pre></td></tr></table></figure>
<p>如果这里的int32_t没有正常对齐。这可能会导致硬件对内存的访问变慢或产生错误。</p>
<hr>
<p>如何修复例子2呢？我们可以使用<code>aligned_storage_t</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">make_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::aligned_storage&lt;<span class="keyword">sizeof</span>(X), <span class="keyword">alignof</span>(x)&gt; storage;</span><br><span class="line">  X* p = <span class="keyword">new</span>(storage) X;</span><br><span class="line">  p-&gt;a = <span class="number">1</span>;</span><br><span class="line">  p-&gt;b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rules-for-valid-value-representations"><a href="#rules-for-valid-value-representations" class="headerlink" title="rules for valid value representations"></a>rules for valid value representations</h2><p>将一个<code>float</code>通过type punning看作<code>int</code>时，这个<code>float</code>的4个bit，变成<code>int</code>后，所表示的<code>int</code>是合法的。</p>
<p>待补充。</p>
<h1 id="正确的type-punning"><a href="#正确的type-punning" class="headerlink" title="正确的type punning"></a>正确的type punning</h1><p>正确的type punning很少：</p>
<ul>
<li>通过一个类型的动态类型访问</li>
<li>通过一个类型的被<code>unsigned</code>或<code>signed</code>修饰的动态类型访问</li>
<li>通过一个<code>char</code>, <code>unsinged char</code>或者<code>std::byte</code>访问</li>
<li>如果两个类型是pointer-interconvertible的（典型的例子为std::complex）</li>
</ul>
<h2 id="pointer-interconvertible"><a href="#pointer-interconvertible" class="headerlink" title="pointer-interconvertible"></a>pointer-interconvertible</h2><p>标准中提到：</p>
<blockquote>
<p>Two objects a and b are pointer-interconvertible if:</p>
<ul>
<li>(4.1) — they are the same object, or</li>
<li>(4.2) — one is a union object and the other is a non-static data member of that object (11.5), or</li>
<li>(4.3) — <strong>one is a standard-layout class object and the other is the first non-static data member of that object</strong>, or, if the object has no non-static data members, any base class subobject of that object (11.4), or</li>
<li>(4.4) — there exists an object c such that a and c are pointer-interconvertible, and c and b are pointer-interconvertible.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">float</span> f = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  <span class="comment">// NOT UB</span></span><br><span class="line">  <span class="keyword">int</span> i = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;w);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中<code>//NOT UB</code>注释下的语句并不是UB，因为<code>Widget</code>和<code>int</code>是pointer-interconvertible的。<code>std::complex</code>是标准钦定的，可以使用type punning的类型。而<code>std::complex</code>正是典型的该性质在标准库中的利用。</p>
<p>标准中对于<code>std::complex</code>提到：</p>
<blockquote>
<p> If z is an lvalue of type cv complex<T> then:</p>
<ul>
<li>(4.1) — the expression <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)</code> is well-formed,</li>
<li>(4.2) — <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]</code> designates the real part of z, and</li>
<li>(4.3) — <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]</code> designates the imaginary part of z.<br>Moreover, if a is an expression of type cv <code>complex&lt;T&gt;*</code> and the expression <code>a[i]</code> is well-defined for an integer expression <code>i</code>, then:</li>
<li>(4.4) — <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</code> designates the real part of a[i], and</li>
<li>(4.5) — <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i + 1]</code> designates the imaginary part of a[i].</li>
</ul>
</blockquote>
<hr>
<h2 id="标准中关于type-punning说明的变化"><a href="#标准中关于type-punning说明的变化" class="headerlink" title="标准中关于type punning说明的变化"></a>标准中关于type punning说明的变化</h2><p>来自<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf" target="_blank" rel="noopener">C++17 final working draft - N4659</a></p>
<blockquote>
<ul>
<li>If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:<ul>
<li>(8.1) — the dynamic type of the object,</li>
<li>(8.2) — a cv-qualified version of the dynamic type of the object,</li>
<li>(8.3) — a type similar (as defined in 7.5) to the dynamic type of the object,</li>
<li>(8.4) — a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>
<li>(8.5) — a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type<br>of the object,</li>
<li>(8.6) — an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>
<li>(8.7) — a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>
<li>(8.8) — a char, unsigned char, or std::byte type.</li>
</ul>
</li>
</ul>
</blockquote>
<p>注意(8.6)中提到，使用union或者aggregate来进行type punning是可行的。然而这和标准中的这段话相矛盾。</p>
<blockquote>
<p>12.3 Unions:<br>In a union, a non-static data member is active if its name refers to an object whose lifetime has begun and has not ended (6.8). <strong>At most one of the non-static data members of an object of union type can be active at any time</strong></p>
</blockquote>
<p>因此出现了下面这提案<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1359r0.html#2051" target="_blank" rel="noopener">P1359r0</a>：</p>
<blockquote>
<p>The aliasing rules of 7.2.1 [basic.lval] paragraph 10 were adapted from C with additions for C++. However, a number of the points either do not apply or are subsumed by other points. For example, the provision for aggregate and union types is needed in C for struct assignment, which in C++ is done via constructors and assignment operators in C++, not by accessing the complete object.</p>
</blockquote>
<p>修复后的<a href="https://isocpp.org/files/papers/N4860.pdf" target="_blank" rel="noopener">C++20 final working draft - N4860</a>去掉了大部分条目，使得规则更精简明确</p>
<blockquote>
<ul>
<li>If a program attempts to access (3.1) the stored value of an object through a glvalue whose type is not similar (7.3.5) to one of the following types the behavior is undefined:<ul>
<li>(11.1) — the dynamic type of the object,</li>
<li>(11.2) — a type that is the signed or unsigned type corresponding to the dynamic type of the object, or</li>
<li>(11.3) — a char, unsigned char, or std::byte type.</li>
</ul>
</li>
</ul>
<p>If a program invokes a defaulted copy/move constructor or copy/move assignment operator for a union of type U with a glvalue argument that does not denote an object of type cv U within its lifetime, the behavior is undefined. [Note: Unlike in C, C++ has no accesses of class type. — end note]</p>
<p>The intent of this list is to specify those circumstances in which an object may or may not be aliased.</p>
</blockquote>
<hr>
<h1 id="错误的type-punning"><a href="#错误的type-punning" class="headerlink" title="错误的type punning"></a>错误的type punning</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    float              float                    float</span><br><span class="line">    +-+-+-+-+          +-+-+-+-+                +-+-+-+-+</span><br><span class="line">+---+ | | | |      +---+ | | | |            +---+ | | | |</span><br><span class="line">|   +-+-+-+-+      |   +-+-+-+-+            |   +-+-+-+-+</span><br><span class="line">|                  |                        |</span><br><span class="line">|   int32_t        |                        |</span><br><span class="line">|   +-+-+-+-+      |   +-+  +-+  +-+  +-+   |   +-+-+  +-+-+</span><br><span class="line">+--&gt;+ | | | |      +--&gt;+ |  | |  | |  | |   +--&gt;+ | |  | | |</span><br><span class="line">    +-+-+-+-+          +-+  +-+  +-+  +-+       +-+-+  +-+-+</span><br><span class="line">                (unsinged) char* &#x2F; std::byte*   int16_t[2]</span><br></pre></td></tr></table></figure>
<ol>
<li>将一个类型看作另一个类型，两个类型的长度相同</li>
<li>将一个类型看作一些单独的bytes</li>
<li>将一个类型看作另一个类型，两个类型的长度不同</li>
</ol>
<p>形式1和形式3往往都是错误的type punning，其中形式1更为常见，经常在一些需要高性能的场景出现。比如下面这一段来自Quake3的<code>FastInvSqrt()</code>的代码<br><a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root#:~:text=Fast%20inverse%20square%20root%2C%20sometimes,IEEE%20754%20floating%2Dpoint%20format." target="_blank" rel="noopener">Fast inverse square root - wikipedia</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="keyword">float</span> number )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">float</span> x2, y;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">  x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">  y  = number;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type Punning</span></span><br><span class="line">  i  = * ( <span class="keyword">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking</span></span><br><span class="line">  i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               <span class="comment">// what the fuck? </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type Punning</span></span><br><span class="line">  y  = * ( <span class="keyword">float</span> * ) &amp;i;</span><br><span class="line">  y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="comment">// 1st iteration</span></span><br><span class="line">  <span class="comment">//	y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed</span></span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第11行和第15行出现了type punning，这种type punning即使在C中也是UB。在C中，可以使用union的方法来修复这段代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="keyword">float</span> number )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span> x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">  &#125; conv = &#123;number&#125;; <span class="comment">// member 'f' set to value of 'number'</span></span><br><span class="line"></span><br><span class="line">  conv.i  = <span class="number">0x5f3759df</span> - (conv.i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  conv.f *= (threehalfs - (x2 * conv.f * conv.f));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> conv.f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但这样的修复方式在C++，无论是根据C++17还是C++20关于type punning的说明，仍然是UB。即便gcc在文档中标注了支持这种type punning： <a href="https://gcc.gnu.org/bugs/#nonbugs" target="_blank" rel="noopener">gcc Non-bugs</a></p>
<blockquote>
<p>… To fix the code above, you can use a union instead of a cast (note that this is a GCC extension which might not work with other compilers) …</p>
</blockquote>
<p>但为了写出portable的代码，我们需要寻找type punning的替代品。</p>
<h1 id="type-punning的替代品"><a href="#type-punning的替代品" class="headerlink" title="type punning的替代品"></a>type punning的替代品</h1><h2 id="std-memcpy"><a href="#std-memcpy" class="headerlink" title="std::memcpy"></a>std::memcpy</h2><p>为了修复Quake3中的UB，我们可以将reinterpret_cast改为memcpy</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="keyword">float</span> number )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">float</span> x2, y;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">  x2 = number * <span class="number">0.5F</span>;</span><br><span class="line">  y  = number;</span><br><span class="line">  <span class="comment">//i  = * ( long * ) &amp;y;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;i, &amp;y, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));    </span><br><span class="line">  i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               </span><br><span class="line">  <span class="comment">//y  = * ( float * ) &amp;i;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;y, &amp;i, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));    </span><br><span class="line">  y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="comment">// 1st iteration</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来讲，编译器都会帮助优化memcpy，并不会产生额外的性能开销。上面的这段代码，修复前和修复后的版本，在gcc，clang，MSVC中都产生了相同的汇编。</p>
<h2 id="std-bit-cast"><a href="#std-bit-cast" class="headerlink" title="std::bit_cast"></a>std::bit_cast</h2><p>C++20加入了<code>constexpr</code>的<code>bit_cast()</code>，方便以<code>memcpy</code>的方式来代替type punning<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">To</span>, <span class="title">class</span> <span class="title">From</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">To</span> <span class="title">bit_cast</span>(<span class="title">const</span> <span class="title">From</span>&amp; <span class="title">from</span>) <span class="title">noexcept</span>;</span></span><br></pre></td></tr></table></figure><br><a href="https://zh.cppreference.com/w/cpp/numeric/bit_cast" target="_blank" rel="noopener">bit_cast - cppreference</a>。注意为了能够调用memcpy，必须满足如下条件</p>
<ul>
<li>sizeof(To) == sizeof(From)</li>
<li>To 和 From 两者都是可平凡复制 (TriviallyCopyable) 类型</li>
</ul>
<p>一个可能的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">To</span>, <span class="title">class</span> <span class="title">From</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">    (<span class="keyword">sizeof</span>(To) == <span class="keyword">sizeof</span>(From)) &amp;&amp;</span><br><span class="line">    <span class="built_in">std</span>::is_trivially_copyable&lt;From&gt;::value &amp;&amp;</span><br><span class="line">    <span class="built_in">std</span>::is_trivially_copyable&lt;To&gt;::value,</span><br><span class="line">    To&gt;::type</span><br><span class="line"><span class="comment">// constexpr 支持需要编译器魔法</span></span><br><span class="line">bit_cast(<span class="keyword">const</span> From &amp;src) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    To dst;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;dst, &amp;src, <span class="keyword">sizeof</span>(To));</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而需要注意的是，在标准中，对<code>bit_cast</code>作出了这样的限制：</p>
<blockquote>
<p>If there is no value of type ‘To’ corresponding to the value represetation produced, the behavior is undefined.</p>
</blockquote>
<h1 id="仍不能修复的type-punning"><a href="#仍不能修复的type-punning" class="headerlink" title="仍不能修复的type punning"></a>仍不能修复的type punning</h1><p>在生产中常会见到这样的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Stream* stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">char</span>[]&gt; buffer = stream-&gt;read();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(buffer[<span class="number">0</span>] == WIDGET)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// UB</span></span><br><span class="line">    processWidget(<span class="keyword">reinterpret_cast</span>&lt;Widget*&gt;(buffer.get()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Widget并没有被created，因此为UB。但是如果Widget不是可平凡复制的，将无法使用<code>memcpy</code>或者<code>bit_cast</code>。为了修复在这种情况下无法找到type punning替代品你的问题，可以查看可能会在C++23进入标准的提案<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0593r4.html" target="_blank" rel="noopener">P0593R4</a>，其中提出了一种产生对象的新方式<code>std::start_lifetime_as</code>。</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_bytes</span><span class="params">(<span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* buf = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(&amp;f);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="keyword">size_t</span>&#123;&#125;; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// UB: buf may not point to the first byte of f</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; buf[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的这段代码中，标准中只说了<code>buf</code>会指向对象<code>f</code>，但没说buf是否会指向<code>f</code>的首个byte。然而在任何的主流编译器中，<code>buf</code>都会指向<code>f</code>的第一个byte。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/cfca6522/" rel="prev" title="N数之和">
      <i class="fa fa-chevron-left"></i> N数之和
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/3ad196a7/" rel="next" title="复制消除、初始化列表与就地构造">
      复制消除、初始化列表与就地构造 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#会导致怎样的ub"><span class="nav-number">1.</span> <span class="nav-text">会导致怎样的ub</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么会导致ub"><span class="nav-number">2.</span> <span class="nav-text">为什么会导致ub</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#aliasing-rules"><span class="nav-number">2.1.</span> <span class="nav-text">aliasing rules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#object-lifetime-rules"><span class="nav-number">2.2.</span> <span class="nav-text">object lifetime rules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#alignment-rules"><span class="nav-number">2.3.</span> <span class="nav-text">alignment rules</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rules-for-valid-value-representations"><span class="nav-number">2.4.</span> <span class="nav-text">rules for valid value representations</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正确的type-punning"><span class="nav-number">3.</span> <span class="nav-text">正确的type punning</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pointer-interconvertible"><span class="nav-number">3.1.</span> <span class="nav-text">pointer-interconvertible</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准中关于type-punning说明的变化"><span class="nav-number">3.2.</span> <span class="nav-text">标准中关于type punning说明的变化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误的type-punning"><span class="nav-number">4.</span> <span class="nav-text">错误的type punning</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#type-punning的替代品"><span class="nav-number">5.</span> <span class="nav-text">type punning的替代品</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#std-memcpy"><span class="nav-number">5.1.</span> <span class="nav-text">std::memcpy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-bit-cast"><span class="nav-number">5.2.</span> <span class="nav-text">std::bit_cast</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#仍不能修复的type-punning"><span class="nav-number">6.</span> <span class="nav-text">仍不能修复的type punning</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他问题"><span class="nav-number">7.</span> <span class="nav-text">其他问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Xuanyi Fu</p>
  <div class="site-description" itemprop="description">Xuanyi Fu的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xuanyi-fu" title="GitHub → https://github.com/xuanyi-fu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5300073738" title="Weibo → https://weibo.com/5300073738" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xuanyi Fu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">139k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:06</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
